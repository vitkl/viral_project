---
title: "Identify if the domains we have identified tend to bind linear motifs (the domains we have identified are enriched in domains known to bind linear motifs)"
author: "Vitalii Kleshchevnikov"
date: "17/08/2017"
output: 
html_document: 
keep_md: yes
toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

packages = c("MItools", "rtracklayer", "ggplot2", "GGally", "RColorBrewer", "R.utils")
if(mean(packages %in% names(installed.packages()[,"Package"])) != 1){
    packages_to_install = packages[!packages %in% names(installed.packages()[,"Package"])]
    # specifying mirror is necessary for some Linux systems
    install.packages(packages_to_install, dependencies = T, repos = "http://mirrors.ebi.ac.uk/CRAN/")
    packages_to_install = packages[!packages %in% names(installed.packages()[,"Package"])]
    source("https://bioconductor.org/biocLite.R")
    biocLite(packages_to_install)
    devtools::install_github("vitkl/MItools")
}

suppressPackageStartupMessages({
    library(MItools)
    library(rtracklayer)
    library(ggplot2)
    library(GGally)
    library(RColorBrewer)
})
```

## Setting up how many cores to use for analysis and fold-enrichment vs freqency

```{r}
# cores to use for multiprocessing: is the number of cores is small -> we are not on a cluster -> use all; if the number of cores is large -> we are on cluster -> use only 15 or 7 or 31 cores (n requested-1)
if(detectCores() <= 4) cores_to_use = detectCores() - 1
if(detectCores() > 4) cores_to_use = 31

# how many permutations?
N_permut = 500000
```

# How many of the domains identified using our approach are in the ELM database (as compared to the population of all domains we tested)?

## Calculate empirical pvalues using count of a domain among interacting partners of viral protein

```{r calculate_pvals_count}
data = fread("./processed_data_files/viral_human_net_w_domains", sep = "\t", stringsAsFactors = F)
# count function: set up standard parameters
permuteCount = function(data, select_nodes = NULL, also_permuteYZ = F){
    res = permutationPval(interactions2permute = IDs_interactor_viral ~ IDs_interactor_human, # first set of interacting pairs (XY) that are to be permuted
                          associations2test = IDs_interactor_viral ~ IDs_domain_human, # set of interacting pairs to be tested (XZ), YZ interactions are assumed
                          node_attr = list(IDs_interactor_viral ~ IDs_interactor_viral_degree,
                                           IDs_domain_human ~ domain_count,
                                           IDs_interactor_viral + IDs_domain_human ~ domain_frequency_per_IDs_interactor_viral),
                          data = data,
                          statistic = IDs_interactor_viral + IDs_domain_human ~ .N,
                          select_nodes = select_nodes,
                          N = N_permut,
                          cores = cores_to_use, seed = 2, also_permuteYZ = also_permuteYZ)
    return(res)
}
# count: all proteins and domains - # permute IDs_interactor_viral ~ IDs_interactor_human
time = proc.time()
res_count = permuteCount(data, select_nodes = NULL)
proc.time() - time
plot(res_count, main = "count: all proteins and domains")
```

```{r calculate_pvals_FisherTest}
# Fisher test: set up standard parameters
permuteFisherTestOdds = function(data, select_nodes = NULL, also_permuteYZ = F, N = N_permut){
    resFISHER = permutationPval(interactions2permute = IDs_interactor_viral ~ IDs_interactor_human, # first set of interacting pairs (XY) that are to be permuted
                                associations2test = IDs_interactor_viral ~ IDs_domain_human, # set of interacting pairs to be tested (XZ), YZ interactions are assumed
                                node_attr = list(IDs_interactor_viral ~ IDs_interactor_viral_degree, # attribute of X
                                                 IDs_domain_human ~ domain_count + N_prot_w_interactors, # attributes of Z
                                                 IDs_interactor_viral + IDs_domain_human ~ domain_count_per_IDs_interactor_viral), # attribute of both X and Z
                                data = data, # data.table containing data
                                statistic = IDs_interactor_viral + IDs_domain_human ~ fisher.test(
                                    matrix(c(domain_count_per_IDs_interactor_viral[1], 
                                             IDs_interactor_viral_degree[1] - domain_count_per_IDs_interactor_viral[1],
                                             domain_count[1] - domain_count_per_IDs_interactor_viral[1], 
                                             N_prot_w_interactors[1] - domain_count[1] - IDs_interactor_viral_degree[1] + domain_count_per_IDs_interactor_viral[1]),
                                           2,2), 
                                    alternative = "greater", conf.int = F)$estimate, # formula to calculate statisic by evaluating right-hand-side expression for each X and Z pair, right-hand-side expression is what is normally put in j in data.table DT[i, j, by], left-hand-side expression contains column names of X and Z which are used in by in data.table
                                select_nodes = select_nodes, # select a subset of the data, only nodes 
                                N = N, # number of permutations
                                cores = cores_to_use, seed = 1, also_permuteYZ = also_permuteYZ)
    # permutationPval returns the number of cases when permuted statitic is higher than the observed statistic (right tail of the distribution), in this case we are interested in the reverse - the lower tail, when p-values from permuted distribution that are lower than the observed p-value
    resFISHER$data_with_pval[, p.value := 1 - p.value]
    return(resFISHER)
}

# permute IDs_interactor_viral ~ IDs_interactor_human: odds ratio
resFISHERodds = permuteFisherTestOdds(data, select_nodes = NULL, N = 1)
resFISHERodds_no1 = permuteFisherTestOdds(data, select_nodes = IDs_interactor_viral + IDs_domain_human ~ domain_count_per_IDs_interactor_viral > 1, N = 1)

# Just FisherTest result (no permutation)
justFisherdata = copy(resFISHERodds$data_with_pval)
justFisherdata[, resFISHERodds_p.value := p.value][, p.value := NULL]
justFisherdata[, odds_ratio := observed_statistic][, observed_statistic := NULL]
justFisherdata[, resFISHERodds_YmissingZ_perX := YmissingZ_perX][, YmissingZ_perX := NULL]
justFisherdata[, resFISHERodds_higher_counts := higher_counts][, higher_counts := NULL]
justFisherdata[, resFISHERodds_not_missing := not_missing][, not_missing := NULL]

justFisherdata_no1 = copy(resFISHERodds_no1$data_with_pval)
justFisherdata_no1[, resFISHERodds_p.value := p.value][, p.value := NULL]
justFisherdata_no1[, odds_ratio := observed_statistic][, observed_statistic := NULL]
justFisherdata_no1[, resFISHERodds_YmissingZ_perX := YmissingZ_perX][, YmissingZ_perX := NULL]
justFisherdata_no1[, resFISHERodds_higher_counts := higher_counts][, higher_counts := NULL]
justFisherdata_no1[, resFISHERodds_not_missing := not_missing][, not_missing := NULL]

# Fisher test: set up standard parameters
permuteFisherTestPval = function(data, select_nodes = NULL, also_permuteYZ = F, N = N_permut){
    resFISHER = permutationPval(interactions2permute = IDs_interactor_viral ~ IDs_interactor_human, # first set of interacting pairs (XY) that are to be permuted
                                associations2test = IDs_interactor_viral ~ IDs_domain_human, # set of interacting pairs to be tested (XZ), YZ interactions are assumed
                                node_attr = list(IDs_interactor_viral ~ IDs_interactor_viral_degree, # attribute of X
                                                 IDs_domain_human ~ domain_count + N_prot_w_interactors, # attributes of Z
                                                 IDs_interactor_viral + IDs_domain_human ~ domain_count_per_IDs_interactor_viral), # attribute of both X and Z
                                data = data, # data.table containing data
                                statistic = IDs_interactor_viral + IDs_domain_human ~ fisher.test(
                                    matrix(c(domain_count_per_IDs_interactor_viral[1], 
                                             IDs_interactor_viral_degree[1] - domain_count_per_IDs_interactor_viral[1],
                                             domain_count[1] - domain_count_per_IDs_interactor_viral[1], 
                                             N_prot_w_interactors[1] - domain_count[1] - IDs_interactor_viral_degree[1] + domain_count_per_IDs_interactor_viral[1]),
                                           2,2), 
                                    alternative = "greater", conf.int = F)$p.value, # formula to calculate statisic by evaluating right-hand-side expression for each X and Z pair, right-hand-side expression is what is normally put in j in data.table DT[i, j, by], left-hand-side expression contains column names of X and Z which are used in by in data.table
                                select_nodes = select_nodes, # select a subset of the data, only nodes 
                                N = N, # number of permutations
                                cores = cores_to_use, seed = 1, also_permuteYZ = also_permuteYZ)
    # permutationPval returns the number of cases when permuted statitic is higher than the observed statistic (right tail of the distribution), in this case we are interested in the reverse - the lower tail, when p-values from permuted distribution that are lower than the observed p-value
    resFISHER$data_with_pval[, p.value := 1 - p.value]
    return(resFISHER)
}

resJustFISHER = permuteFisherTestPval(justFisherdata, select_nodes = NULL, N = 1)
resJustFISHER_no1 = permuteFisherTestPval(justFisherdata_no1, select_nodes = IDs_interactor_viral + IDs_domain_human ~ domain_count_per_IDs_interactor_viral > 1, N = 1)

resJustFISHER$data_with_pval[, p.value := observed_statistic]
resJustFISHER$data_with_pval[, observed_statistic := odds_ratio]

resJustFISHER_no1$data_with_pval[, p.value := observed_statistic]
resJustFISHER_no1$data_with_pval[, observed_statistic := odds_ratio]

my.p.adjust = function(res, adj_by = "p.value", ...) {
    if(class(res) != "XYZinteration_XZEmpiricalPval") stop("res should be the output of permutationPval()")
    if("fdr_pval" %in% colnames(res$data_with_pval)) stop("p value has already been fdr-corrected")
    columns = adj_by
    adj_by = formula(paste0("~",adj_by))[[2]]
    nodes = c(res$nodes$nodeX, res$nodes$nodeZ)
    columns = c(nodes, columns)
    temp = unique(res$data_with_pval[, c(columns), with = F])
    temp[, fdr_pval := p.adjust(eval(adj_by), ...)]
    res$data_with_pval = res$data_with_pval[temp, on = c(columns)]
    res
}
resJustFISHER = my.p.adjust(resJustFISHER, method = "fdr")
resJustFISHER_no1 = my.p.adjust(resJustFISHER_no1, method = "fdr")

resJustFISHER005 = copy(resJustFISHER)
resJustFISHER005$data_with_pval = resJustFISHER$data_with_pval[fdr_pval < 0.05,]
resJustFISHER01 = copy(resJustFISHER)
resJustFISHER01$data_with_pval = resJustFISHER$data_with_pval[fdr_pval < 0.1,]
resJustFISHER001 = copy(resJustFISHER)
resJustFISHER001$data_with_pval = resJustFISHER$data_with_pval[fdr_pval < 0.01,]
```

```{r bayes1}
# Fisher test gives the probability of the domain being enriched over the background P(D)
# If we do just the Fisher test we see that the top-scoring domains (overwhelming majority) are those seen at count 1, we need to account for the probability of seeing different counts while looking at viral proteins individually
# Permutations give the probability of seeing specific domain counts P(count)
# P(cound|D) are the frequencies of each count as is while looking at viral proteins individually
# We want to find P(D|count) = (P(count|D) * P(D)) / P(count)
# P.D_count. = P.count_D. * P.D. / P.count.
bayes = function(resJustFISHER, res_count, P.D. = "p.value", P.count. = "p.value", degree = "IDs_interactor_viral_degree", count = "domain_count_per_IDs_interactor_viral"){
    if(identical(c(resJustFISHER$nodes$nodeX, resJustFISHER$nodes$nodeZ),
                 c(res_count$nodes$nodeX, res_count$nodes$nodeZ))) {
        nodes = c(res_count$nodes$nodeX, res_count$nodes$nodeZ)
    } else stop("resJustFISHER and res_count contain data for different nodes")
    count_data = unique(res_count$data_with_pval[, c(nodes, P.count., degree, count,"observed_statistic"), with = F])
    count_data[, domains_per_prot := .N, by = .(eval(formula(paste0("~",res_count$nodes$nodeX))[[2]]))]
    count_data[, P.count_D. := .N / domains_per_prot, 
               by = .(eval(formula("~observed_statistic")[[2]]),
                      eval(formula(paste0("~",res_count$nodes$nodeX))[[2]]))]
    # count_data[, P.count_D. := eval(formula(paste0("~",count))[[2]]) / eval(formula(paste0("~",degree))[[2]])]
    count_data[, P.count. := p.value]
    count_data[, c("p.value", "observed_statistic", "domains_per_prot") := NULL]
    
    just_fisher = copy(resJustFISHER)
    just_fisher$data_with_pval = just_fisher$data_with_pval[count_data, on = nodes]
    just_fisher$data_with_pval[, P.D. := eval(formula(paste0("~",P.D.))[[2]])]
    
    just_fisher$data_with_pval[, P.D. := 1 - P.D.]
    just_fisher$data_with_pval[, P.count_D. := P.count_D.]
    just_fisher$data_with_pval[, P.count. := 1 - P.count.]
    just_fisher$data_with_pval[, P.D_count. := P.count_D. * P.D. / P.count.]
    
    just_fisher$data_with_pval[, p.value := 1 - P.D_count.]
    
    just_fisher
}

resBayes = bayes(resJustFISHER, res_count)
plot(resJustFISHER, IDs_interactor_viral + IDs_domain_human ~ fdr_pval)
plot(resBayes, IDs_interactor_viral + IDs_domain_human ~ P.count_D.)
```

```{r bayes2}
bayes2 = function(resJustFISHER, res_count, P.D. = "p.value", P.count. = "p.value", degree = "IDs_interactor_viral_degree", count = "domain_count_per_IDs_interactor_viral"){
    if(identical(c(resJustFISHER$nodes$nodeX, resJustFISHER$nodes$nodeZ),
                 c(res_count$nodes$nodeX, res_count$nodes$nodeZ))) {
        nodes = c(res_count$nodes$nodeX, res_count$nodes$nodeZ)
    } else stop("resJustFISHER and res_count contain data for different nodes")
    count_data = unique(res_count$data_with_pval[, c(nodes, P.count., degree, count,"observed_statistic"), with = F])
    count_data[, prots_per_domain := .N, by = .(eval(formula(paste0("~",res_count$nodes$nodeZ))[[2]]))]
    #count_data[, P.count_D. := .N / prots_per_domain, 
    #               by = .(eval(formula("~observed_statistic")[[2]]),
    #                                      eval(formula(paste0("~",res_count$nodes$nodeZ))[[2]]))]
    count_data[, P.count_D. := p.value]
    count_data[, P.count. := p.value]
    count_data[, c("p.value", "observed_statistic", "domains_per_prot") := NULL]
    
    just_fisher = copy(resJustFISHER)
    just_fisher$data_with_pval = just_fisher$data_with_pval[count_data, on = nodes]
    just_fisher$data_with_pval[, P.D. := eval(formula(paste0("~",P.D.))[[2]])]
    
    just_fisher$data_with_pval[, P.D. := 1 - P.D.]
    just_fisher$data_with_pval[, P.count_D. := P.count_D.]
    just_fisher$data_with_pval[, P.count. := 1 - P.count.]
    just_fisher$data_with_pval[, P.D_count. := P.count_D. * P.D. / P.count.]
    
    just_fisher$data_with_pval[, p.value := 1 - P.D_count.]
    
    just_fisher
}

resBayes2 = bayes2(resJustFISHER, res_count)
plot(resBayes2, IDs_interactor_viral + IDs_domain_human ~ p.value)
```

```{r bayes3}
# Permutations give the probability of seeing any domain specific number of times P(count)
# P(cound|D) are the frequencies of each count as is while looking at viral proteins individually
# We want to find P(D|count) = (P(count|D) * P(D)) / P(count)
# P.D_count. = P.count_D. * P.D. / P.count.
bayes3 = function(res_count){
    res_bayes = copy(res_count)
    nodes = c(res_bayes$nodes$nodeX, res_bayes$nodes$nodeZ)
    res = unique(res_bayes$data_with_pval[, c(nodes, "observed_statistic", "p.value", "domain_frequency"), with = F])
    res_3 = res[, c(nodes, "observed_statistic"), with = F]
    res_3 = res[res_3, on = nodes[2], allow.cartesian=TRUE]
    res_3[, P.count_D. := mean(observed_statistic < i.observed_statistic), by = eval(nodes)]
    res_3 = unique(res_3[,c(nodes, "observed_statistic", "p.value", "domain_frequency", "P.count_D."), with =F])
    res_3[, P.count. := 1 - p.value]
    res_3[, P.D. := 1 - domain_frequency]
    
    res_3[, P.D_count. := P.count_D. *  P.D. / P.count.]
    
    res_bayes$data_with_pval = res_bayes$data_with_pval[res_3, on = c(nodes, "observed_statistic", "p.value", "domain_frequency")]
    res_bayes$data_with_pval[, p.value := 1- P.D_count.]
    #hist(res_bayes$data_with_pval[, P.D_count.])
    #hist(res_bayes$data_with_pval[, P.count_D.])
    #hist(res_bayes$data_with_pval[, P.D.])
    #hist(res_bayes$data_with_pval[, P.count.])
    res_bayes
}

resBayes3 = bayes3(res_count)
plot(resBayes3)

Pmultiply =  function(res_count, resJustFISHER, invert = F){
    if(identical(c(resJustFISHER$nodes$nodeX, resJustFISHER$nodes$nodeZ),
                 c(res_count$nodes$nodeX, res_count$nodes$nodeZ))) {
        nodes = c(res_count$nodes$nodeX, res_count$nodes$nodeZ)
    } else stop("resJustFISHER and res_count contain data for different nodes")
    res_mult = copy(res_count)
    fisher = unique(resJustFISHER$data_with_pval[,c(nodes, "p.value"), with = F])
    if(invert){
        fisher[, p.value := 1 - p.value]
        res_mult$data_with_pval[, p.value := 1 - p.value]
    }
    res_mult$data_with_pval = res_mult$data_with_pval[fisher, on = nodes]
    res_mult$data_with_pval[, p.value := p.value * i.p.value][, i.p.value := NULL]
    if(invert) res_mult$data_with_pval[, p.value := 1 - p.value]
    return(res_mult)
}
resPmult = Pmultiply(res_count, resJustFISHER)
plot(resPmult)
resPmultInv = Pmultiply(res_count, resJustFISHER, invert = T)
plot(resPmultInv)
```

```{r sequential_filter}
step1 = unique(res_count$data_with_pval[, c(res_count$nodes$nodeX, res_count$nodes$nodeZ, "p.value"), with = F])
step1 = step1[p.adjust(p.value, "fdr") < 0.05]
step1 = step1[, Emp.p.value := p.value]
sequential_filter = copy(resJustFISHER)
sequential_filter$data_with_pval = sequential_filter$data_with_pval[step1, on = eval(c(res_count$nodes$nodeX, res_count$nodes$nodeZ)), nomatch = 0]
```

## Viral protein degree and the background domain count of top-scoring proteins

```{r plot_DegreeVScount, fig.height = 12, fig.width = 12, eval=FALSE}
# count
PermutResult2D(res = res_count, N = 250) +
    ggtitle("2D-bin plots of 250 top-scoring viral protein - human domain pairs, \n statistic: count of a domain among interacting partners of a viral protein")

# Fisher test p-value
PermutResult2D(res = resJustFISHER, N = 250) + 
    ggtitle("2D-bin plots of 250 top-scoring viral protein - human domain pairs, \n statistic: Fisher test p-value")
```

## Map domains known to interact with linear motifs from ELM to the domains we found

```{r ELMdownload_and_map}
if(!file.exists("./data_files/interactiondomains.tsv")) downloader::download("http://elm.eu.org/interactiondomains.tsv","./data_files/interactiondomains.tsv")
interactiondomains = fread("./data_files/interactiondomains.tsv")
interactiondomains[, pfam_id := `Interaction Domain Id`]

domains_known = interactiondomains[, unique(pfam_id)]

InterProScan_domains = readInterProGFF3("../viral_project/processed_data_files/all_human_viral_protein_domains.gff3.gz")
# get InterProID to member database ID mapping
InterPro2memberDB = getInterPro2memberDB(InterProScan_domains)
InterPro2memberDB = InterPro2memberDB[complete.cases(InterPro2memberDB)]
domains_known_mapped = unique(InterPro2memberDB[memberDBID %in% domains_known | InterProID %in% domains_known, InterProID])
domains_not_mapped = unique(domains_known[!(domains_known %in% InterPro2memberDB$memberDBID | domains_known %in% InterPro2memberDB$InterProID)])
```

I did Fisher test to evaluate if the domains that we find are enriched in domains known to interact with linear motifs (from ELM). I have picked some number of viral protein - human domain associations from the top (by p-value). Then I counted how many known domains we have found and did Fisher test. I decided to compare two statistic choices (frequency of a domain among interacting partners of a viral protein or Fisher test p-value) on how many of the known domains we tend to find. Finally, I was choosing different cutoffs (different number of top p-value pairs). 

```{r overrepresentation_test}
testEnrichment = function(N, res, rank_by = "p.value", domains_known_mapped, random = F, name = "", decreasing = F){
    if(random) {
        res$data_pval = unique(res$data_with_pval[,c("IDs_interactor_viral", "IDs_domain_human", rank_by, "domain_type", "domain_count", "IDs_interactor_viral_degree"), with = F])
        domains_found = res$data_pval[sample(1:nrow(res$data_with_pval), N), unique(IDs_domain_human)]
    } else {
        res$data_pval = unique(res$data_with_pval[,c("IDs_interactor_viral", "IDs_domain_human", rank_by, "domain_type", "domain_count", "IDs_interactor_viral_degree"), with = F])
        ind = order(unlist(res$data_pval[, c(rank_by), with = F]), decreasing = decreasing)[1:N] 
        domains_found = res$data_pval[ind, unique(IDs_domain_human)]
    }
    
    alldomains = res$data_with_pval[, unique(IDs_domain_human)]
    known = factor(alldomains %in% domains_known_mapped, levels = c("TRUE", "FALSE"))
    found = factor(alldomains %in% domains_found, levels = c("TRUE", "FALSE"))
    table_res = table(known, found)
    
    test = fisher.test(table(known, found), alternative = "greater", conf.int = T)
    
    return(c(pval = test$p.value, odds_ratio = as.vector(test$estimate),
             count = table_res["TRUE", "TRUE"], total_count = sum(as.logical(found)),
             name = name))
}
runningTestEnrichment = function(res, name, rank_by = "p.value", decreasing = F){
    enrichment = sapply(Ns, testEnrichment, res = res, 
                        domains_known_mapped = domains_known_mapped, 
                        name = name, rank_by = rank_by, decreasing = decreasing)
    colnames(enrichment) = Ns
    return(enrichment)
}

Ns = seq(25, 500, 25)
# count
enrichment = runningTestEnrichment(res_count, name = "domain frequency among interactors of a viral protein, empirical pval")
enrichment_justfreq = runningTestEnrichment(res_count, rank_by = "observed_statistic", name = "domain count among interactors of a viral protein, frequency")

# Fisher test pval
enrichmentresJustFISHER = runningTestEnrichment(resJustFISHER, rank_by = "p.value", name = "Fisher test pval: domain overrepresentation over the background")
enrichmentressequential_filter = runningTestEnrichment(sequential_filter, rank_by = "p.value", name = "Sequential filter: domain frequency among interactors of a viral protein (empirical pval) =>\ndomain overrepresentation over the background")
enrichmentresJustFISHER_no1 = runningTestEnrichment(resJustFISHER_no1, rank_by = "p.value", name = "Fisher test pval: domain overrepresentation over the background, domain count 1 removed")

enrichmentresJustFISHER005 = runningTestEnrichment(resJustFISHER005, rank_by = "observed_statistic", name = "odds ratio: domain overrepresentation over the background, filtered by Fisher test pval 0.05", decreasing = T)
enrichmentresJustFISHER01 = runningTestEnrichment(resJustFISHER01, rank_by = "observed_statistic", name = "odds ratio: domain overrepresentation over the background, filtered by Fisher test pval 0.1", decreasing = T)
enrichmentresJustFISHER001 = runningTestEnrichment(resJustFISHER001, rank_by = "observed_statistic", name = "odds ratio: domain overrepresentation over the background, filtered by Fisher test pval 0.01", decreasing = T)

# Bayes
enrichmentBayes = runningTestEnrichment(resBayes, name = "Bayesian approach: integrating count and domain probabilities P(D|count) = (P(count|D) * P(D)) / P(count)")
enrichmentBayes2 = runningTestEnrichment(resBayes2, name = "Bayesian approach 2: integrating count and domain probabilities P(D|count) = (P(count|D) * P(D)) / P(count)")
enrichmentBayes3 = runningTestEnrichment(resBayes3, name = "Bayesian approach 3: (P(count|D):what_are_usual_counts * P(D):background) / P(count):perm")

# Multipliying count and Fisher test probabilities
enrichmentPmult = runningTestEnrichment(resPmult, name = "Multipliying count empirical p-value and Fisher test probability")
enrichmentPmultInv = runningTestEnrichment(resPmultInv, name = "Multipliying (inverted, p = 1 - p) count empirical p-value and Fisher test probability")

random_domains = function(N = 100, seed = seed, Ns = seq(25, 500, 25), res){
    set.seed(seed)
    
    quantiles = c(0.975, 0.75, 0.5, 0.25, 0.025)
    quantile_names = c("97.5% quantile", "75% quantile", "median", "25% quantile", "2.5% quantile")
    
    pval_temp = replicate(N, {
        enrichmentRANDOM = sapply(Ns, testEnrichment, res = res, domains_known_mapped = domains_known_mapped, random = T, name = "N random proteins")[1,]
        names(enrichmentRANDOM) = Ns
        as.numeric(enrichmentRANDOM)
    })
    pval = apply(pval_temp, 1, quantile, probs = quantiles)
    rownames(pval) = quantile_names
    colnames(pval) = Ns
    
    odds_ratio_temp = replicate(N, {
        enrichmentRANDOM = sapply(Ns, testEnrichment, res = res, domains_known_mapped = domains_known_mapped, random = T, name = "N random proteins")[2,]
        names(enrichmentRANDOM) = Ns
        as.numeric(enrichmentRANDOM)
    })
    odds_ratio = apply(odds_ratio_temp, 1, quantile, probs = quantiles)
    rownames(odds_ratio) = quantile_names
    colnames(odds_ratio) = Ns
    
    count_temp = replicate(N, {
        enrichmentRANDOM = sapply(Ns, testEnrichment, res = res, domains_known_mapped = domains_known_mapped, random = T, name = "N random proteins")[3,]
        names(enrichmentRANDOM) = Ns
        as.numeric(enrichmentRANDOM)
    })
    count = apply(count_temp, 1, quantile, probs = quantiles)
    rownames(count) = quantile_names
    colnames(count) = Ns
    
    return(list(pval = pval, odds_ratio = odds_ratio, count = count))
}

enrichmentRANDOM = random_domains(1000, 1, res = res_count)
```

## As we include more proteins, the number of known domains we find increases and then levels off (probably because some of the known domains do not interact with viral proteins).

```{r domains_found, fig.height = 9, fig.width = 10, eval=FALSE}
plotEnrichment(enrichment, enrichmentBayes, enrichment_justfreq, enrichment_low_back, enrichment_low_deg, enrichment_low_deg_back,
               enrichmentRev, enrichmentMix,
               enrichmentFISHERodds, enrichmentFISHER_justodds,
               enrichmentFISHERpval, enrichmentFISHER_justpval, enrichmentFISHERoddsBig,
               random_domains = enrichmentRANDOM, 
               domains_known_mapped = domains_known_mapped, type = "count", plot_type = "l")
```

## As we include more proteins, the Fisher test odds ratio decreases (we add more stuff that is not known). Odds ratio measures how much more likely are we to find a domain using our procedure if it’s a known domain as compared to if it’s not a known domain.

```{r fisher_odds_ratio, fig.height = 9, fig.width = 10, eval=FALSE}
plotEnrichment(enrichment, enrichment_justfreq,
               enrichmentresJustFISHER, enrichmentresJustFISHER005,
               enrichmentresJustFISHER01, enrichmentresJustFISHER001,
               enrichmentBayes, enrichmentBayes2,
               random_domains = enrichmentRANDOM, 
               domains_known_mapped = domains_known_mapped, type = "odds_ratio", plot_type = "l")
```

## corresponding P-values from the Fisher test 

```{r fisher_pval, fig.height = 9, fig.width = 10, eval=FALSE}
plotEnrichment(enrichment, enrichment_justfreq,
               enrichmentresJustFISHER, enrichmentresJustFISHER005,
               enrichmentresJustFISHER01, enrichmentresJustFISHER001,
               enrichmentBayes, enrichmentBayes2,
               random_domains = enrichmentRANDOM, 
               domains_known_mapped = domains_known_mapped, type = "pval", plot_type = "l")
```

## How many viral proteins are known per each of the domain instances in top 200 protein-domain pairs?

```{r top200_n_inter}
selectTopHits = function(res, N){
    res$data_pval = unique(res$data_with_pval[,.(IDs_interactor_viral, IDs_domain_human, p.value, domain_type, domain_count, IDs_interactor_viral_degree)])
    pairs200pval = res$data_pval[order(p.value, decreasing = F)[1:N], max(p.value)]
    
    restop100 = res
    restop100$data_with_pval = restop100$data_with_pval[p.value <= pairs200pval, ]
    restop100$data_with_pval[, N_viral_per_human_w_domain := length(unique(IDs_interactor_viral)), by = .(IDs_interactor_human, IDs_domain_human)]
    return(restop100)
}
restop100 = selectTopHits(res_count, N = 250)
plot(restop100, IDs_interactor_human ~ N_viral_per_human_w_domain)
plot(restop100)
```

`r restop100$data_with_pval[N_viral_per_human_w_domain >= 5, length(unique(IDs_interactor_human))]` human proteins with enriched domains have 5 or more viral interacting partners.  
`r restop100$data_with_pval[N_viral_per_human_w_domain >= 10, length(unique(IDs_interactor_human))]` human proteins with enriched domains have 10 or more viral interacting partners.  

### what are those domains? are they known ELM-interacting domains? which proteins they are in? which viral taxons they interact with?

```{r}
restop100$data_with_pval[N_viral_per_human_w_domain >= 10, unique(IDs_domain_human)]
restop100$data_with_pval[N_viral_per_human_w_domain >= 10, unique(IDs_domain_human)] %in% domains_known_mapped
restop100$data_with_pval[N_viral_per_human_w_domain >= 10 & IDs_domain_human == "IPR000504", unique(IDs_interactor_human)]
restop100$data_with_pval[N_viral_per_human_w_domain >= 10 & IDs_domain_human == "IPR000504", unique(Taxid_interactor_viral)]
DT::datatable(restop100$data_with_pval[N_viral_per_human_w_domain >= 10,])
```

## R session information

```{r}
filename = paste0("./processed_data_files/what_we_find_VS_ELM_clust",gsub("-","",Sys.Date()),".RData")
filename = paste0("./processed_data_files/what_we_find_VS_ELM_clust",gsub("-","","2017-10-19"),".RData")
save(list = ls(), file=filename)
#R.utils::gzip(filename = "./processed_data_files/what_we_find_VS_ELM_clust11092017.RData",
#              destname = "./processed_data_files/what_we_find_VS_ELM_clust11092017.RData.gz",
#              remove = T, overwrite = T)
Sys.Date()
sessionInfo()
```
