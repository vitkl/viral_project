---
title: "Identify if the domains we have identified tend to bind linear motifs (the domains we have identified are enriched in domains known to bind linear motifs)"
author: "Vitalii Kleshchevnikov"
date: "17/08/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

packages = c("MItools", "rtracklayer", "ggplot2", "GGally", "RColorBrewer")
if(mean(packages %in% names(installed.packages()[,"Package"])) != 1){
    packages_to_install = packages[!packages %in% names(installed.packages()[,"Package"])]
    # specifying mirror is necessary for some Linux systems
    install.packages(packages_to_install, dependencies = T, repos = "http://mirrors.ebi.ac.uk/CRAN/")
    packages_to_install = packages[!packages %in% names(installed.packages()[,"Package"])]
    source("https://bioconductor.org/biocLite.R")
    biocLite(packages_to_install)
    devtools::install_github("vitkl/MItools")
}

suppressPackageStartupMessages({
    library(MItools)
    library(rtracklayer)
    library(ggplot2)
    library(GGally)
    library(RColorBrewer)
})
```

## Setting up how many cores to use for analysis and fold-enrichment vs freqency

```{r}
# cores to use for multiprocessing: is the number of cores is small -> we are not on a cluster -> use all; if the number of cores is large -> we are on cluster -> use only 15 or 7 cores
if(detectCores() <= 4) cores_to_use = detectCores() - 1
if(detectCores() > 4) cores_to_use = 15

# how many permutations?
N_permut = 1000
```

# How many of the domains identified using our approach are in the ELM database (as compared to the population of all domains we tested)?

## Calculate empirical pvalues using either frequency of a domain among interacting partners of viral protein or Fisher test p-value

```{r calculate_pvals}
# frequency function: set up standard parameters
permuteFrequency = function(data, select_nodes = NULL){
    res = permutationPval(interactions2permute = IDs_interactor_viral ~ IDs_interactor_human, # first set of interacting pairs (XY) that are to be permuted
                          associations2test = IDs_interactor_viral ~ IDs_domain_human, # set of interacting pairs to be tested (XZ), YZ interactions are assumed
                          node_attr = list(IDs_interactor_viral ~ IDs_interactor_viral_degree,
                                           IDs_domain_human ~ domain_count,
                                           IDs_interactor_viral + IDs_domain_human ~ domain_frequency_per_IDs_interactor_viral),
                          data = data,
                          statistic = IDs_interactor_viral + IDs_domain_human ~ .N / IDs_interactor_viral_degree,
                          select_nodes = select_nodes,
                          N = N_permut,
                          cores = cores_to_use, seed = 2)
    return(res)
}
data = fread("./processed_data_files/viral_human_net_w_domains", sep = "\t", stringsAsFactors = F)

# frequency: all proteins and domains
time = proc.time()
res = permuteFrequency(data, select_nodes = NULL)
proc.time() - time
permutationPvalPlot(res, main = "frequency: all proteins and domains")

# frequency: removed low background count domains
res_low_back = permuteFrequency(data, select_nodes = IDs_domain_human ~ domain_count >= 3)
permutationPvalPlot(res_low_back, main = "frequency: removed low background count domains (>= 3)")

# frequency: not considering (fixing interactions, degree of every node in the network stays the same, but only high degree proteins are taken into account, equivalent to  permuting only interactions of protein with the degree higher than 1) and viral proteins with the degree of 1
res_low_deg = permuteFrequency(data, select_nodes = IDs_interactor_viral ~ IDs_interactor_viral_degree >= 2)
permutationPvalPlot(res_low_deg, main = "frequency: not considering viral proteins with the degree of 1")

# frequency: BOTH removed low background count domains AND considering viral proteins with the degree of 1

res_low_deg_back = permuteFrequency(data, select_nodes = list(IDs_domain_human ~ domain_count >= 3,
                                                              IDs_interactor_viral ~ IDs_interactor_viral_degree >= 2))
permutationPvalPlot(res_low_deg_back, main = "frequency: removed low background count domains (>= 3)\nAND not considering viral proteins with the degree of 1")

# Fisher test: set up standard parameters
permuteFisherTest = function(data, select_nodes = NULL){
    resFISHER = permutationPval(interactions2permute = IDs_interactor_viral ~ IDs_interactor_human, # first set of interacting pairs (XY) that are to be permuted
                                associations2test = IDs_interactor_viral ~ IDs_domain_human, # set of interacting pairs to be tested (XZ), YZ interactions are assumed
                                node_attr = list(IDs_interactor_viral ~ IDs_interactor_viral_degree, # attribute of X
                                                 IDs_domain_human ~ domain_count + N_prot_w_interactors, # attributes of Z
                                                 IDs_interactor_viral + IDs_domain_human ~ domain_count_per_IDs_interactor_viral), # attribute of both X and Z
                                data = data, # data.table containing data
                                statistic = IDs_interactor_viral + IDs_domain_human ~ fisher.test(
                                    matrix(c(unique(domain_count_per_IDs_interactor_viral), 
                                             unique(IDs_interactor_viral_degree) - unique(domain_count_per_IDs_interactor_viral),
                                             unique(domain_count), 
                                             unique(N_prot_w_interactors) - unique(domain_count)),
                                           2,2), 
                                    alternative = "greater", conf.int = F)$p.value, # formula to calculate statisic by evaluating right-hand-side expression for each X and Z pair, right-hand-side expression is what is normally put in j in data.table DT[i, j, by], left-hand-side expression contains column names of X and Z which are used in by in data.table
                                select_nodes = select_nodes, # select a subset of the data, only nodes 
                                N = N_permut, # number of permutations
                                cores = cores_to_use, seed = 1)
    # permutationPval returns the number of cases when permuted statitic is higher than the observed statistic (right tail of the distribution), in this case we are interested in the reverse - the lower tail, when p-values from permuted distribution that are lower than the observed p-value
    resFISHER$data_with_pval[, p.value := 1 - p.value]
    return(resFISHER)
}
# contingency matrix:
matrix(c("unique(domain_count_per_IDs_interactor_viral)", 
         "unique(IDs_interactor_viral_degree) - unique(domain_count_per_IDs_interactor_viral)", 
         "unique(domain_count)", 
         "unique(N_prot_w_interactors) - unique(domain_count)"),2,2)
# test
time = proc.time()
resFISHER = permuteFisherTest(data, select_nodes = NULL)
proc.time() - time
permutationPvalPlot(resFISHER, main = "Fisher test P-value: all proteins and domains")
```

## Viral protein degree and the background domain count of top-scoring proteins

```{r plot_DegreeVScount, fig.height = 12, fig.width = 12}
# simplify data for plotting
resFISHER$data_pval_simp = unique(resFISHER$data_with_pval[, .(IDs_interactor_viral, IDs_domain_human, IDs_interactor_viral_degree, domain_count, domain_count_per_IDs_interactor_viral, p.value)])
res$data_pval_simp = unique(res$data_with_pval[, .(IDs_interactor_viral, IDs_domain_human, IDs_interactor_viral_degree, domain_count, domain_count_per_IDs_interactor_viral, p.value)])

# function to accomodate ggplot2::geom_bin2d in GGally::ggpairs, taken from http://ggobi.github.io/ggally/#custom_functions
d2_bin_log10 <- function(data, mapping, ..., low = "#132B43", high = "#56B1F7") {
    ggplot(data = data, mapping = mapping) +
        geom_bin2d(...) +
        scale_fill_gradient(low = low, high = high) +
        scale_y_log10() + scale_x_log10()
}

log10_density = function(data, mapping, ...){
    ggplot(data = data, mapping = mapping) +
        geom_density(...) +
        scale_x_log10()
}

PermutResult2D = function(res, N){
    GGally::ggpairs(res$data_pval_simp[order(p.value)[1:N],.(domain_count, 
                                                             IDs_interactor_viral_degree, 
                                                             domain_count_per_IDs_interactor_viral,
                                                             p.value)], 
                    lower = list(continuous = d2_bin_log10)#, 
                    #diag = list(continuous = geom_density)
    ) +
        theme_light() +
        theme(strip.text.y = element_text(angle = 0, size = 10),
              strip.text.x = element_text(angle = 90, size = 10))
}

# frequency of a domain
PermutResult2D(res = res, N = 250) +
    ggtitle("2D-bin plots of 250 top-scoring viral protein - human domain pairs, \n statistic: frequency of a domain among interacting partners of a viral protein")
# frequency of a domain: removed low background count domains
PermutResult2D(res = res, N = 250) +
    ggtitle("2D-bin plots of 250 top-scoring viral protein - human domain pairs, \n statistic: frequency of a domain among interacting partners of a viral protein \n removed low background count domains")

# Fisher test p-value
PermutResult2D(res = resFISHER, N = 250) + 
    ggtitle("2D-bin plots of 250 top-scoring viral protein - human domain pairs, \n statistic: Fisher test p-value")
```

## Map domains known to interact with linear motifs from ELM to the domains we found

```{r ELMdownload_and_map}
interactiondomains = fread("http://elm.eu.org/interactiondomains.tsv")
interactiondomains[, pfam_id := `Interaction Domain Id`]

domains_known = interactiondomains[, unique(pfam_id)]

"./processed_data_files/InterProScan_domains_nonredundant.gff3"
"./processed_data_files/all_human_viral_protein_domains.gff3.gz"
InterProScan_domains_nonred = import(con = "../viral_project/processed_data_files/InterProScan_domains_nonredundant.gff3", format = "gff3")
domains_mapping = unique(data.table(any_id = as.character(InterProScan_domains_nonred$Name), interpro_id = as.character(InterProScan_domains_nonred$Dbxref)))
domains_known_mapped = unique(domains_mapping[any_id %in% domains_known, interpro_id])
domains_not_mapped = unique(domains_known[!domains_known %in% domains_mapping$any_id])
```

I did Fisher test to evaluate if the domains that we find are enriched in domains known to interact with linear motifs (from ELM). I have picked some number of viral protein - human domain associations from the top (by p-value). Then I counted how many known domains we have found and did Fisher test. I decided to compare two statistic choices (frequency of a domain among interacting partners of a viral protein or Fisher test p-value) on how many of the known domains we tend to find. Finally, I was choosing different cutoffs (different number of top p-value pairs). 

```{r overrepresentation_test}
test_enrichment = function(N, res, domains_known_mapped, random = F, name = ""){
    if(random) {domains_found = res$data_pval[sample(1:nrow(res$data_pval), N), unique(IDs_domain_human)]}
    if(!random){
        res$data_pval = unique(res$data_with_pval[,.(IDs_interactor_viral, IDs_domain_human, p.value, domain_type, domain_count, IDs_interactor_viral_degree)])
        res$data_pval[, pval_fdr := p.adjust(p.value, method = "fdr")]
        # hist(res$data_pval[, pval_fdr], breaks = seq(0,1,0.01))
        
        domains_found = res$data_pval[order(p.value)[1:N], unique(IDs_domain_human)]
    }
    
    alldomains = res$data_pval[, unique(IDs_domain_human)]
    known = factor(alldomains %in% domains_known_mapped, levels = c("TRUE", "FALSE"))
    found = factor(alldomains %in% domains_found, levels = c("TRUE", "FALSE"))
    table_res = table(known, found)
    
    test = fisher.test(table(known, found), alternative = "greater", conf.int = T)
    
    return(c(pval = test$p.value, odds_ratio = test$estimate, count = table_res["TRUE", "TRUE"], name = name))
}

enrichment = sapply(seq(25, 500, 25), test_enrichment, res, domains_known_mapped, name = "domain frequency among interactors of a viral protein")
colnames(enrichment) = seq(25, 500, 25)
enrichment_low_back = sapply(seq(25, 500, 25), test_enrichment, res_low_back, domains_known_mapped, name = "domain frequency: low background removed")
colnames(enrichment_low_back) = seq(25, 500, 25)
enrichment_low_deg = sapply(seq(25, 500, 25), test_enrichment, res_low_deg, domains_known_mapped, name = "domain frequency: degree of 1 removed")
colnames(enrichment_low_deg) = seq(25, 500, 25)
enrichment_low_deg_back = sapply(seq(25, 500, 25), test_enrichment, res_low_deg_back, domains_known_mapped, name = "domain frequency: degree of 1 AND low background removed")
colnames(enrichment_low_deg_back) = seq(25, 500, 25)
enrichmentFISHER = sapply(seq(25, 500, 25), test_enrichment, resFISHER, domains_known_mapped, name = "Fisher test pval: domain overrepresentation over the background")
colnames(enrichmentFISHER) = seq(25, 500, 25)

set.seed(1)
X = replicate(1, {
    enrichmentRANDOM = sapply(seq(25, 500, 25), test_enrichment, res, domains_known_mapped, random = T, name = "N random proteins")[1:3,]
    colnames(enrichmentRANDOM) = seq(25, 500, 25)
    #enrichmentRANDOM[1,] = as.numeric(enrichmentRANDOM[1,])
    #enrichmentRANDOM[2,] = as.numeric(enrichmentRANDOM[2,])
    #enrichmentRANDOM[3,] = as.numeric(enrichmentRANDOM[3,])
    enrichmentRANDOM
})

```

## As we include more proteins, the number of known domains we find increases and then levels off (probably because some of the known domains do not interact with viral proteins).

```{r domains_found, fig.height = 6, fig.width = 9}
plotEnrichment = function(..., domains_known_mapped, type = "count", plot_type = plot_type){
    
    res = list(...)
    typenum = match(type, c("pval", "odds_ratio", "count"))
    ngroups = length(res)
    
    if(type == "count") color = brewer.pal(ngroups + 1, "Dark2") else color = brewer.pal(ngroups, "Dark2")
    if(is.na(typenum)) stop("'type' should be one of “count”, “odds_ratio”, “pval”")
    
    leg_pos_y = max(sapply(res, function(x, typenum) max(as.numeric(x[typenum,])), typenum))
    if(type == "count") leg_pos_y = length(domains_known_mapped) - 1
    leg_pos_x = max(sapply(res, function(x) max(as.numeric(colnames(x))))) * 0.16
    
    if(type == "pval") ylim = c(0, 1)
    if(type == "count") ylim = c(0,length(domains_known_mapped)+1)
    if(type == "odds_ratio") ylim = c(0,leg_pos_y)
    
    plot(colnames(res[[1]]), res[[1]][typenum,], 
         ylab = "known domain found", xlab = "top N viral protein - domain pairs selected", 
         col = color[1], type = plot_type, ylim = ylim)
    
    for (i in 2:ngroups) {
        lines(x = colnames(res[[i]]), y = res[[i]][typenum,], col = color[i], type = plot_type)
    }
    
    if(type == "count") abline(h = length(domains_known_mapped), col = color[ngroups + 1])
    
    legend_names = c("statictic used in permutation test:")
    for(i in 1:ngroups){
        legend_names = c(legend_names, unique(res[[i]]["name",]))
    }
    
    if(type == "count") legend_names = c(legend_names, "domains known to interact with linear motifs")
    
    legend(x = leg_pos_x, y = leg_pos_y, legend_names, 
           col = c("white", color), lty = 1 , merge = TRUE)
}

plotEnrichment(enrichment, enrichment_low_back, enrichment_low_deg, enrichment_low_deg_back, enrichmentFISHER, enrichmentRANDOM, 
               domains_known_mapped = domains_known_mapped, type = "count", plot_type = "l")
```

## As we include more proteins, the Fisher test odds ratio decreases (we add more stuff that is not known). Odds ratio measures how much more likely are we to find a domain using our procedure if it’s a known domain as compared to if it’s not a known domain.

```{r fisher_odds_ratio, fig.height = 6, fig.width = 9}
plotEnrichment(enrichment, enrichmentFISHER, enrichmentRANDOM, domains_known_mapped = domains_known_mapped, type = "pval", plot_type = "l")
```

## corresponding P-values from the Fisher test 

```{r fisher_pval, fig.height = 6, fig.width = 9}
plot(colnames(enrichment), enrichment[1,], ylab = "Fisher test pvalue", xlab = "top N viral protein - domain pairs selected", col = "red", type = "l", ylim = c(0,max(c(enrichment[1,], enrichmentFISHER[1,]))))
lines(x = colnames(enrichment), y = enrichmentFISHER[1,], col = "blue", type = "l")
lines(x = colnames(enrichment), y = enrichmentRANDOM[1,], col = "violet", type = "l")
legend(x = 80, y = max(c(enrichment[1,], enrichmentFISHER[1,])), c("statictic used in permutation test:","domain frequency among interactors of a viral protein", "Fisher test pval: domain overrepresentation over the background", "N random proteins"), col = c("white","red", "blue", "violet"), lty = 1 ,merge = TRUE)
```


## R session information

```{r}
#rm(list = ls())
gc()
Sys.Date()
sessionInfo()
```