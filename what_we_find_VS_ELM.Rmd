---
title: "Identify if the domains we have identified tend to bind linear motifs (the domains we have identified are enriched in domains known to bind linear motifs)"
author: "Vitalii Kleshchevnikov"
date: "17/08/2017"
output: 
  html_document: 
    keep_md: yes
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

packages = c("MItools", "rtracklayer", "ggplot2", "GGally", "RColorBrewer", "R.utils")
if(mean(packages %in% names(installed.packages()[,"Package"])) != 1){
    packages_to_install = packages[!packages %in% names(installed.packages()[,"Package"])]
    # specifying mirror is necessary for some Linux systems
    install.packages(packages_to_install, dependencies = T, repos = "http://mirrors.ebi.ac.uk/CRAN/")
    packages_to_install = packages[!packages %in% names(installed.packages()[,"Package"])]
    source("https://bioconductor.org/biocLite.R")
    biocLite(packages_to_install)
    devtools::install_github("vitkl/MItools")
}

suppressPackageStartupMessages({
    library(MItools)
    library(rtracklayer)
    library(ggplot2)
    library(GGally)
    library(RColorBrewer)
})
```

## Setting up how many cores to use for analysis and fold-enrichment vs freqency

```{r}
# cores to use for multiprocessing: is the number of cores is small -> we are not on a cluster -> use all; if the number of cores is large -> we are on cluster -> use only 15 or 7 or 31 cores (n requested-1)
if(detectCores() <= 4) cores_to_use = detectCores() - 1
if(detectCores() > 4) cores_to_use = 31

# how many permutations?
N_permut = 50000
```

# How many of the domains identified using our approach are in the ELM database (as compared to the population of all domains we tested)?

## Calculate empirical pvalues using either frequency of a domain among interacting partners of viral protein or Fisher test p-value

```{r calculate_pvals_freq}
data = fread("./processed_data_files/viral_human_net_w_domains", sep = "\t", stringsAsFactors = F)
# frequency function: set up standard parameters
permuteFrequency = function(data, select_nodes = NULL, also_permuteYZ = F){
    res = permutationPval(interactions2permute = IDs_interactor_viral ~ IDs_interactor_human, # first set of interacting pairs (XY) that are to be permuted
                          associations2test = IDs_interactor_viral ~ IDs_domain_human, # set of interacting pairs to be tested (XZ), YZ interactions are assumed
                          node_attr = list(IDs_interactor_viral ~ IDs_interactor_viral_degree,
                                           IDs_domain_human ~ domain_count,
                                           IDs_interactor_viral + IDs_domain_human ~ domain_frequency_per_IDs_interactor_viral),
                          data = data,
                          statistic = IDs_interactor_viral + IDs_domain_human ~ .N / IDs_interactor_viral_degree,
                          select_nodes = select_nodes,
                          N = N_permut,
                          cores = cores_to_use, seed = 2, also_permuteYZ = also_permuteYZ)
    return(res)
}

# frequency: all proteins and domains - # permute IDs_interactor_viral ~ IDs_interactor_human
time = proc.time()
res = permuteFrequency(data, select_nodes = NULL)
proc.time() - time
plot(res, main = "frequency: all proteins and domains")

# frequency: no low background count domains
res_low_back = permuteFrequency(data, select_nodes = IDs_domain_human ~ domain_count >= 3)
#res_low_back_alt = permuteFrequency(data[domain_count >= 3,])
#all.equal(res_low_back$data_with_pval[complete.cases(res_low_back$data_with_pval),p.value], res_low_back_alt$data_with_pval[complete.cases(res_low_back_alt$data_with_pval),p.value])
plot(res_low_back, main = "frequency: no low background count domains (>= 3)")

# frequency: not considering (fixing interactions, degree of every node in the network stays the same, but only high degree proteins are taken into account, equivalent to  permuting only interactions of protein with the degree higher than 1) viral proteins with the degree of 1 - removing viral proteins with the degree of 1
res_low_deg = permuteFrequency(data, select_nodes = IDs_interactor_viral ~ IDs_interactor_viral_degree >= 2)
#res_low_deg_alt = permuteFrequency(data[IDs_interactor_viral_degree >= 2,])
#all.equal(res_low_deg$data_with_pval[complete.cases(res_low_deg$data_with_pval),p.value], res_low_deg_alt$data_with_pval[complete.cases(res_low_deg_alt$data_with_pval),p.value])

plot(res_low_deg, main = "frequency: not considering viral proteins with the degree of 1")

# frequency: BOTH no low background count domains AND removing viral proteins with the degree of 1

res_low_deg_back = permuteFrequency(data, select_nodes = list(IDs_domain_human ~ domain_count >= 3,
                                                              IDs_interactor_viral ~ IDs_interactor_viral_degree >= 2))
#res_low_deg_back_alt = permuteFrequency(data[domain_count >= 3 & IDs_interactor_viral_degree >= 2,])
#all.equal(res_low_deg_back$data_with_pval[complete.cases(res_low_deg_back$data_with_pval),p.value], res_low_deg_back_alt$data_with_pval[complete.cases(res_low_deg_back_alt$data_with_pval),p.value])
plot(res_low_deg_back, main = "frequency: no low background count domains (>= 3)\nAND not considering viral proteins with the degree of 1")

save(res, file="./processed_data_files/what_we_find_VS_ELM_output_freq.RData")
```

```{r calculate_pvals_count}
# count function: set up standard parameters
permuteCount = function(data, select_nodes = NULL, also_permuteYZ = F){
    res = permutationPval(interactions2permute = IDs_interactor_viral ~ IDs_interactor_human, # first set of interacting pairs (XY) that are to be permuted
                          associations2test = IDs_interactor_viral ~ IDs_domain_human, # set of interacting pairs to be tested (XZ), YZ interactions are assumed
                          node_attr = list(IDs_interactor_viral ~ IDs_interactor_viral_degree,
                                           IDs_domain_human ~ domain_count,
                                           IDs_interactor_viral + IDs_domain_human ~ domain_frequency_per_IDs_interactor_viral),
                          data = data,
                          statistic = IDs_interactor_viral + IDs_domain_human ~ .N,
                          select_nodes = select_nodes,
                          N = N_permut,
                          cores = cores_to_use, seed = 2, also_permuteYZ = also_permuteYZ)
    return(res)
}
# count: all proteins and domains - # permute IDs_interactor_viral ~ IDs_interactor_human
time = proc.time()
res_count = permuteCount(data, select_nodes = NULL)
proc.time() - time
plot(res_count, main = "count: all proteins and domains")

save(list = ls(), file="./processed_data_files/what_we_find_VS_ELM_clust.RData")
```

```{r calculate_pvals_FisherTest}
# Fisher test: set up standard parameters
permuteFisherTestPval = function(data, select_nodes = NULL, also_permuteYZ = F, N = N_permut){
    resFISHER = permutationPval(interactions2permute = IDs_interactor_viral ~ IDs_interactor_human, # first set of interacting pairs (XY) that are to be permuted
                                associations2test = IDs_interactor_viral ~ IDs_domain_human, # set of interacting pairs to be tested (XZ), YZ interactions are assumed
                                node_attr = list(IDs_interactor_viral ~ IDs_interactor_viral_degree, # attribute of X
                                                 IDs_domain_human ~ domain_count + N_prot_w_interactors, # attributes of Z
                                                 IDs_interactor_viral + IDs_domain_human ~ domain_count_per_IDs_interactor_viral), # attribute of both X and Z
                                data = data, # data.table containing data
                                statistic = IDs_interactor_viral + IDs_domain_human ~ fisher.test(
                                    matrix(c(domain_count_per_IDs_interactor_viral[1], 
                                             IDs_interactor_viral_degree[1] - domain_count_per_IDs_interactor_viral[1],
                                             domain_count[1] - domain_count_per_IDs_interactor_viral[1], 
                                             N_prot_w_interactors[1] - domain_count[1] - IDs_interactor_viral_degree[1] + domain_count_per_IDs_interactor_viral[1]),
                                           2,2), 
                                    alternative = "greater", conf.int = F)$p.value, # formula to calculate statisic by evaluating right-hand-side expression for each X and Z pair, right-hand-side expression is what is normally put in j in data.table DT[i, j, by], left-hand-side expression contains column names of X and Z which are used in by in data.table
                                select_nodes = select_nodes, # select a subset of the data, only nodes 
                                N = N, # number of permutations
                                cores = cores_to_use, seed = 1, also_permuteYZ = also_permuteYZ)
    # permutationPval returns the number of cases when permuted statitic is higher than the observed statistic (right tail of the distribution), in this case we are interested in the reverse - the lower tail, when p-values from permuted distribution that are lower than the observed p-value
    resFISHER$data_with_pval[, p.value := 1 - p.value]
    return(resFISHER)
}

# contingency matrix:
matrix(c("domain_count_per_IDs_interactor_viral[1]", 
         "IDs_interactor_viral_degree[1] - domain_count_per_IDs_interactor_viral[1]",
         "domain_count[1] - domain_count_per_IDs_interactor_viral[1]", 
         "N_prot_w_interactors[1] - domain_count[1] - IDs_interactor_viral_degree[1] + domain_count_per_IDs_interactor_viral[1]"),
       2,2)
# permute IDs_interactor_viral ~ IDs_interactor_human
time = proc.time()
resFISHERpval = permuteFisherTestPval(data, select_nodes = NULL)
proc.time() - time
plot(resFISHERpval, main = "Fisher test P-value: all proteins and domains")


# Fisher test: set up standard parameters
permuteFisherTestOdds = function(data, select_nodes = NULL, also_permuteYZ = F){
    resFISHER = permutationPval(interactions2permute = IDs_interactor_viral ~ IDs_interactor_human, # first set of interacting pairs (XY) that are to be permuted
                                associations2test = IDs_interactor_viral ~ IDs_domain_human, # set of interacting pairs to be tested (XZ), YZ interactions are assumed
                                node_attr = list(IDs_interactor_viral ~ IDs_interactor_viral_degree, # attribute of X
                                                 IDs_domain_human ~ domain_count + N_prot_w_interactors, # attributes of Z
                                                 IDs_interactor_viral + IDs_domain_human ~ domain_count_per_IDs_interactor_viral), # attribute of both X and Z
                                data = data, # data.table containing data
                                statistic = IDs_interactor_viral + IDs_domain_human ~ fisher.test(
                                    matrix(c(domain_count_per_IDs_interactor_viral[1], 
                                             IDs_interactor_viral_degree[1] - domain_count_per_IDs_interactor_viral[1],
                                             domain_count[1] - domain_count_per_IDs_interactor_viral[1], 
                                             N_prot_w_interactors[1] - domain_count[1] - IDs_interactor_viral_degree[1] + domain_count_per_IDs_interactor_viral[1]),
                                           2,2), 
                                    alternative = "greater", conf.int = F)$estimate, # formula to calculate statisic by evaluating right-hand-side expression for each X and Z pair, right-hand-side expression is what is normally put in j in data.table DT[i, j, by], left-hand-side expression contains column names of X and Z which are used in by in data.table
                                select_nodes = select_nodes, # select a subset of the data, only nodes 
                                N = N_permut, # number of permutations
                                cores = cores_to_use, seed = 1, also_permuteYZ = also_permuteYZ)
    # permutationPval returns the number of cases when permuted statitic is higher than the observed statistic (right tail of the distribution), in this case we are interested in the reverse - the lower tail, when p-values from permuted distribution that are lower than the observed p-value
    resFISHER$data_with_pval[, p.value := 1 - p.value]
    return(resFISHER)
}

# permute IDs_interactor_viral ~ IDs_interactor_human: odds ratio
time = proc.time()
resFISHERodds = permuteFisherTestOdds(data, select_nodes = NULL)
proc.time() - time
plot(resFISHERodds, main = "Fisher test odds ratio: all proteins and domains")

# permute IDs_interactor_viral ~ IDs_interactor_human: odds ratio, remove all small values
time = proc.time()
resFISHERoddsBig = permuteFisherTestOdds(data, select_nodes = list(IDs_domain_human ~ domain_count >= 15,
                                                                   IDs_interactor_viral ~ IDs_interactor_viral_degree >= 15))
proc.time() - time
plot(resFISHERoddsBig, main = "Fisher test odds ratio: removed small (>= 15)\ndomain count and degree")

save(resFISHERodds, file="./processed_data_files/what_we_find_VS_ELM_output_FISHER.RData")

# Just FisherTest result (no permutation)
justFisherdata = copy(resFISHERodds$data_with_pval)
justFisherdata[, resFISHERodds_p.value := p.value][, p.value := NULL]
justFisherdata[, odds_ratio := observed_statistic][, observed_statistic := NULL]
justFisherdata[, resFISHERodds_YmissingZ_perX := YmissingZ_perX][, YmissingZ_perX := NULL]
justFisherdata[, resFISHERodds_higher_counts := higher_counts][, higher_counts := NULL]
justFisherdata[, resFISHERodds_not_missing := not_missing][, not_missing := NULL]

resJustFISHER = permuteFisherTestPval(justFisherdata, select_nodes = NULL, N = 1)

resJustFISHER$data_with_pval[, p.value := observed_statistic]
resJustFISHER$data_with_pval[, observed_statistic := odds_ratio]

my.p.adjust = function(res, adj_by = "p.value", ...) {
    if(class(res) != "XYZinteration_XZEmpiricalPval") stop("res should be the output of permutationPval()")
    if("fdr_pval" %in% colnames(res$data_with_pval)) stop("p value has already been fdr-corrected")
    columns = adj_by
    adj_by = formula(paste0("~",adj_by))[[2]]
    nodes = c(res$nodes$nodeX, res$nodes$nodeZ)
    columns = c(nodes, columns)
    temp = unique(res$data_with_pval[, c(columns), with = F])
    temp[, fdr_pval := p.adjust(eval(adj_by), ...)]
    res$data_with_pval = res$data_with_pval[temp, on = c(columns)]
    res
}
resJustFISHER = my.p.adjust(resJustFISHER, method = "fdr")
resJustFISHER005 = copy(resJustFISHER)
resJustFISHER005$data_with_pval = resJustFISHER$data_with_pval[fdr_pval < 0.05,]
resJustFISHER01 = copy(resJustFISHER)
resJustFISHER01$data_with_pval = resJustFISHER$data_with_pval[fdr_pval < 0.1,]
resJustFISHER001 = copy(resJustFISHER)
resJustFISHER001$data_with_pval = resJustFISHER$data_with_pval[fdr_pval < 0.01,]

# Fisher test gives the probability of the domain being enriched over the background P(D)
# If we do just the Fisher test we see that the top-scoring domains (overwhelming majority) are those seen at count 1, we need to account for the probability of seeing different counts while looking at viral proteins individually
# Permutations give the probability of seeing specific domain counts P(count)
# P(cound|D) are the frequencies of each count as is while looking at viral proteins individually
# We want to find P(D|count) = (P(count|D) * P(D)) / P(count)
# P.D_count. = P.count_D. * P.D. / P.count.
bayes = function(resJustFISHER, res_count, P.D. = "p.value", P.count. = "p.value", degree = "IDs_interactor_viral_degree", count = "domain_count_per_IDs_interactor_viral"){
    if(identical(c(resJustFISHER$nodes$nodeX, resJustFISHER$nodes$nodeZ),
                 c(res_count$nodes$nodeX, res_count$nodes$nodeZ))) {
        nodes = c(res_count$nodes$nodeX, res_count$nodes$nodeZ)
    } else stop("resJustFISHER and res_count contain data for different nodes")
    count_data = unique(res_count$data_with_pval[, c(nodes, P.count., degree, count,"observed_statistic"), with = F])
    count_data[, domains_per_prot := .N, by = .(eval(formula(paste0("~",res_count$nodes$nodeX))[[2]]))]
    count_data[, P.count_D. := .N / domains_per_prot, 
                   by = .(eval(formula("~observed_statistic")[[2]]),
                                          eval(formula(paste0("~",res_count$nodes$nodeX))[[2]]))]
    # count_data[, P.count_D. := eval(formula(paste0("~",count))[[2]]) / eval(formula(paste0("~",degree))[[2]])]
    count_data[, P.count. := p.value]
    count_data[, c("p.value", "observed_statistic", "domains_per_prot") := NULL]
    
    just_fisher = copy(resJustFISHER)
    just_fisher$data_with_pval = just_fisher$data_with_pval[count_data, on = nodes]
    just_fisher$data_with_pval[, P.D. := eval(formula(paste0("~",P.D.))[[2]])]
    
    just_fisher$data_with_pval[, P.D. := 1 - P.D.]
    just_fisher$data_with_pval[, P.count_D. := P.count_D.]
    just_fisher$data_with_pval[, P.count. := 1 - P.count.]
    just_fisher$data_with_pval[, P.D_count. := P.count_D. * P.D. / P.count.]
    
    just_fisher$data_with_pval[, p.value := 1 - P.D_count.]
    
    just_fisher
}

resBayes = bayes(resJustFISHER, res_count)
plot(resJustFISHER, IDs_interactor_viral + IDs_domain_human ~ fdr_pval)
plot(resBayes, IDs_interactor_viral + IDs_domain_human ~ P.count_D.)
```

```{r bayes2}
bayes2 = function(resJustFISHER, res_count, P.D. = "p.value", P.count. = "p.value", degree = "IDs_interactor_viral_degree", count = "domain_count_per_IDs_interactor_viral"){
    if(identical(c(resJustFISHER$nodes$nodeX, resJustFISHER$nodes$nodeZ),
                 c(res_count$nodes$nodeX, res_count$nodes$nodeZ))) {
        nodes = c(res_count$nodes$nodeX, res_count$nodes$nodeZ)
    } else stop("resJustFISHER and res_count contain data for different nodes")
    count_data = unique(res_count$data_with_pval[, c(nodes, P.count., degree, count,"observed_statistic"), with = F])
    count_data[, prots_per_domain := .N, by = .(eval(formula(paste0("~",res_count$nodes$nodeZ))[[2]]))]
    #count_data[, P.count_D. := .N / prots_per_domain, 
    #               by = .(eval(formula("~observed_statistic")[[2]]),
    #                                      eval(formula(paste0("~",res_count$nodes$nodeZ))[[2]]))]
    count_data[, P.count_D. := p.value]
    count_data[, P.count. := p.value]
    count_data[, c("p.value", "observed_statistic", "domains_per_prot") := NULL]
    
    just_fisher = copy(resJustFISHER)
    just_fisher$data_with_pval = just_fisher$data_with_pval[count_data, on = nodes]
    just_fisher$data_with_pval[, P.D. := eval(formula(paste0("~",P.D.))[[2]])]
    
    just_fisher$data_with_pval[, P.D. := 1 - P.D.]
    just_fisher$data_with_pval[, P.count_D. := P.count_D.]
    just_fisher$data_with_pval[, P.count. := 1 - P.count.]
    just_fisher$data_with_pval[, P.D_count. := P.count_D. * P.D. / P.count.]
    
    just_fisher$data_with_pval[, p.value := 1 - P.D_count.]
    
    just_fisher
}

resBayes2 = bayes2(resJustFISHER, res_count)
plot(resBayes2, IDs_interactor_viral + IDs_domain_human ~ p.value)
```

```{r calculate_pvals_freq_rev}
# frequency function: set up standard parameters
permuteFrequencyRev = function(data, select_nodes = NULL, also_permuteYZ = F){
    res = permutationPval(interactions2permute = IDs_domain_human ~ IDs_interactor_human, # first set of interacting pairs (XY) that are to be permuted
                          associations2test = IDs_domain_human ~ IDs_interactor_viral, # set of interacting pairs to be tested (XZ), YZ interactions are assumed
                          node_attr = list(IDs_interactor_viral ~ IDs_interactor_viral_degree,
                                           IDs_domain_human ~ domain_count,
                                           IDs_interactor_viral + IDs_domain_human ~ domain_frequency_per_IDs_interactor_viral),
                          data = data,
                          statistic = IDs_interactor_viral + IDs_domain_human ~ .N / domain_count,
                          select_nodes = select_nodes,
                          N = N_permut,
                          cores = cores_to_use, seed = 2, also_permuteYZ = also_permuteYZ)
    return(res)
}

# frequency: all proteins and domains - # permute IDs_domain_human ~ IDs_interactor_human
time = proc.time()
resRev = permuteFrequencyRev(data, select_nodes = NULL)
proc.time() - time
plot(resRev, main = "frequency reverse: viral protein frequency among proteins with a domain")
# multiply one way and the reverse-way probabilities
mix = resRev
mix$data_with_pval = resRev$data_with_pval[res$data_with_pval, on = c("IDs_domain_human", "IDs_interactor_viral", "IDs_interactor_human", "domain_type", "N_prot_w_interactors", "domain_count", "domain_frequency", "Taxid_interactor_human", "Taxid_interactor_viral", "IDs_interactor_viral_degree", "domain_frequency_per_IDs_interactor_viral", "fold_enrichment", "IDs_interactor_viral_per_IDs_domain_human", "domain_count_per_IDs_interactor_viral", "IDs_interactor_human_degree", "IDs_domain_human_per_IDs_interactor_viral")]
mix$data_with_pval[, p.value := p.value * i.p.value]
plot(mix, main = "frequency mix: p-val viral protein-domain * p-val domain-viral protein")

save(mix, file="./processed_data_files/what_we_find_VS_ELM_output_freq_mix.RData")
```

## Viral protein degree and the background domain count of top-scoring proteins

```{r plot_DegreeVScount, fig.height = 12, fig.width = 12, eval=FALSE}
# frequency
PermutResult2D(res = res, N = 250) +
    ggtitle("2D-bin plots of 250 top-scoring viral protein - human domain pairs, \n statistic: frequency of a domain among interacting partners of a viral protein (viral-domain)")
PermutResult2D(res = res_low_back, N = 250) +
    ggtitle("2D-bin plots of 250 top-scoring viral protein - human domain pairs, \n statistic: frequency of a domain among interacting partners of a viral protein \n no low background count domains")
PermutResult2D(res = res_low_deg, N = 250) +
    ggtitle("2D-bin plots of 250 top-scoring viral protein - human domain pairs, \n statistic: frequency of a domain among interacting partners of a viral protein \n no viral proteins with the degree of 1")
PermutResult2D(res = res_low_deg_back, N = 250) +
    ggtitle("2D-bin plots of 250 top-scoring viral protein - human domain pairs, \n statistic: frequency of a domain among interacting partners of a viral protein \n no low background count domains \nAND no viral proteins with the degree of 1")

# count
PermutResult2D(res = res_count, N = 250) +
    ggtitle("2D-bin plots of 250 top-scoring viral protein - human domain pairs, \n statistic: count of a domain among interacting partners of a viral protein")

# reverse frequency
PermutResult2D(res = res, N = 250) +
    ggtitle("2D-bin plots of 250 top-scoring viral protein - human domain pairs, \n statistic: viral protein frequency among proteins with a domain")
PermutResult2D(res = mix, N = 250) +
    ggtitle("2D-bin plots of 250 top-scoring viral protein - human domain pairs, \n statistic: frequency p-val viral protein-domain * frequency p-val domain-viral protein")

# Fisher test p-value
PermutResult2D(res = resFISHER, N = 250) + 
    ggtitle("2D-bin plots of 250 top-scoring viral protein - human domain pairs, \n statistic: Fisher test p-value")
```

## Map domains known to interact with linear motifs from ELM to the domains we found

```{r ELMdownload_and_map}
interactiondomains = fread("http://elm.eu.org/interactiondomains.tsv")
interactiondomains[, pfam_id := `Interaction Domain Id`]

domains_known = interactiondomains[, unique(pfam_id)]

InterProScan_domains = readInterProGFF3("../viral_project/processed_data_files/all_human_viral_protein_domains.gff3.gz")
# get InterProID to member database ID mapping
InterPro2memberDB = getInterPro2memberDB(InterProScan_domains)
InterPro2memberDB = InterPro2memberDB[complete.cases(InterPro2memberDB)]
domains_known_mapped = unique(InterPro2memberDB[memberDBID %in% domains_known | InterProID %in% domains_known, InterProID])
domains_not_mapped = unique(domains_known[!(domains_known %in% InterPro2memberDB$memberDBID | domains_known %in% InterPro2memberDB$InterProID)])
```

I did Fisher test to evaluate if the domains that we find are enriched in domains known to interact with linear motifs (from ELM). I have picked some number of viral protein - human domain associations from the top (by p-value). Then I counted how many known domains we have found and did Fisher test. I decided to compare two statistic choices (frequency of a domain among interacting partners of a viral protein or Fisher test p-value) on how many of the known domains we tend to find. Finally, I was choosing different cutoffs (different number of top p-value pairs). 

```{r overrepresentation_test}
testEnrichment = function(N, res, rank_by = "p.value", domains_known_mapped, random = F, name = "", decreasing = F){
    if(random) {
        res$data_pval = unique(res$data_with_pval[,c("IDs_interactor_viral", "IDs_domain_human", rank_by, "domain_type", "domain_count", "IDs_interactor_viral_degree"), with = F])
        domains_found = res$data_pval[sample(1:nrow(res$data_with_pval), N), unique(IDs_domain_human)]
    } else {
        res$data_pval = unique(res$data_with_pval[,c("IDs_interactor_viral", "IDs_domain_human", rank_by, "domain_type", "domain_count", "IDs_interactor_viral_degree"), with = F])
        ind = order(unlist(res$data_pval[, c(rank_by), with = F]), decreasing = decreasing)[1:N] 
        domains_found = res$data_pval[ind, unique(IDs_domain_human)]
    }
    
    alldomains = res$data_with_pval[, unique(IDs_domain_human)]
    known = factor(alldomains %in% domains_known_mapped, levels = c("TRUE", "FALSE"))
    found = factor(alldomains %in% domains_found, levels = c("TRUE", "FALSE"))
    table_res = table(known, found)
    
    test = fisher.test(table(known, found), alternative = "greater", conf.int = T)
    
    return(c(pval = test$p.value, odds_ratio = as.vector(test$estimate),
             count = table_res["TRUE", "TRUE"], total_count = sum(as.logical(found)),
             name = name))
}
runningTestEnrichment = function(res, name, rank_by = "p.value", decreasing = F){
    enrichment = sapply(Ns, testEnrichment, res = res, 
                        domains_known_mapped = domains_known_mapped, 
                        name = name, rank_by = rank_by, decreasing = decreasing)
    colnames(enrichment) = Ns
    return(enrichment)
}

Ns = seq(25, 500, 25)
# frequency
enrichment = runningTestEnrichment(res, name = "domain frequency among interactors of a viral protein, empirical pval")
enrichment_justfreq = runningTestEnrichment(res, rank_by = "observed_statistic", name = "domain frequency among interactors of a viral protein, frequency")
enrichment_low_back = runningTestEnrichment(res_low_back, name = "domain frequency: no low background, empirical pval")
enrichment_low_deg = runningTestEnrichment(res_low_deg, name = "domain frequency: no degree of 1, empirical pval")
enrichment_low_deg_back = runningTestEnrichment(res_low_deg_back, name = "domain frequency: no degree of 1 AND no low background, empirical pval")

# reverse frequency and mix
enrichmentRev = runningTestEnrichment(resRev, name = "viral protein frequency among proteins with a domain, empirical pval")
enrichmentMix = runningTestEnrichment(mix, name = "mix of viral protein -> domain and domain -> viral protein, empirical pval")

# count
enrichment_count = runningTestEnrichment(res_count, name = "domain count among interactors of a viral protein, empirical pval")

# Fisher test pval
enrichmentFISHERodds = runningTestEnrichment(resFISHERodds, name = "Fisher test odds ratio: domain overrepresentation over the background, empirical pval")
enrichmentFISHERpval = runningTestEnrichment(resFISHERpval, name = "Fisher test pval: domain overrepresentation over the background, empirical pval")
enrichmentFISHER_justodds = runningTestEnrichment(resFISHERodds, rank_by = "observed_statistic", name = "odds ratio: domain overrepresentation over the background, decreasing rank", decreasing = T)
enrichmentFISHER_justoddsIncreasing = runningTestEnrichment(resFISHERodds, rank_by = "observed_statistic", name = "odds ratio: domain overrepresentation over the background, increasing rank", decreasing = F)
enrichmentFISHERpval = runningTestEnrichment(resFISHERpval, name = "Fisher test pval: domain overrepresentation over the background, empirical pval")
enrichmentFISHER_justpval = runningTestEnrichment(resFISHERpval, rank_by = "observed_statistic", name = "Fisher test pval: domain overrepresentation over the background")
enrichmentFISHERoddsBig = runningTestEnrichment(resFISHERoddsBig, name = "Fisher test odds ratio: domain overrepresentation over the background \n(background count and degree >= 15), empirical pval")

enrichmentresJustFISHER005 = runningTestEnrichment(resJustFISHER005, rank_by = "observed_statistic", name = "odds ratio: domain overrepresentation over the background, filtered by Fisher test pval 0.05", decreasing = T)
enrichmentresJustFISHER01 = runningTestEnrichment(resJustFISHER01, rank_by = "observed_statistic", name = "odds ratio: domain overrepresentation over the background, filtered by Fisher test pval 0.1", decreasing = T)
enrichmentresJustFISHER001 = runningTestEnrichment(resJustFISHER001, rank_by = "observed_statistic", name = "odds ratio: domain overrepresentation over the background, filtered by Fisher test pval 0.01", decreasing = T)

# Bayes
enrichmentBayes = runningTestEnrichment(resBayes, name = "Bayesian approach: integrating count and domain probabilities P(D|count) = (P(count|D) * P(D)) / P(count)")
enrichmentBayes2 = runningTestEnrichment(resBayes2, name = "Bayesian approach 2: integrating count and domain probabilities P(D|count) = (P(count|D) * P(D)) / P(count)")


random_domains = function(N = 100, seed = seed, Ns = seq(25, 500, 25)){
    set.seed(seed)
    
    quantiles = c(0.975, 0.75, 0.5, 0.25, 0.025)
    quantile_names = c("97.5% quantile", "75% quantile", "median", "25% quantile", "2.5% quantile")
    
    pval_temp = replicate(N, {
        enrichmentRANDOM = sapply(Ns, testEnrichment, res = res, domains_known_mapped = domains_known_mapped, random = T, name = "N random proteins")[1,]
        names(enrichmentRANDOM) = Ns
        as.numeric(enrichmentRANDOM)
    })
    pval = apply(pval_temp, 1, quantile, probs = quantiles)
    rownames(pval) = quantile_names
    colnames(pval) = Ns
    
    odds_ratio_temp = replicate(N, {
        enrichmentRANDOM = sapply(Ns, testEnrichment, res = res, domains_known_mapped = domains_known_mapped, random = T, name = "N random proteins")[2,]
        names(enrichmentRANDOM) = Ns
        as.numeric(enrichmentRANDOM)
    })
    odds_ratio = apply(odds_ratio_temp, 1, quantile, probs = quantiles)
    rownames(odds_ratio) = quantile_names
    colnames(odds_ratio) = Ns
    
    count_temp = replicate(N, {
        enrichmentRANDOM = sapply(Ns, testEnrichment, res = res, domains_known_mapped = domains_known_mapped, random = T, name = "N random proteins")[3,]
        names(enrichmentRANDOM) = Ns
        as.numeric(enrichmentRANDOM)
    })
    count = apply(count_temp, 1, quantile, probs = quantiles)
    rownames(count) = quantile_names
    colnames(count) = Ns
    
    return(list(pval = pval, odds_ratio = odds_ratio, count = count))
}

enrichmentRANDOM = random_domains(1000, 1)
save(list = ls(), file="./processed_data_files/what_we_find_VS_ELM_clust.RData")
```

## As we include more proteins, the number of known domains we find increases and then levels off (probably because some of the known domains do not interact with viral proteins).

```{r domains_found, fig.height = 9, fig.width = 10}
plotEnrichment(enrichment, enrichmentBayes, enrichment_justfreq, enrichment_low_back, enrichment_low_deg, enrichment_low_deg_back,
               enrichment_count, enrichmentRev, enrichmentMix,
               enrichmentFISHERodds, enrichmentFISHER_justodds,
               enrichmentFISHERpval, enrichmentFISHER_justpval, enrichmentFISHERoddsBig,
               random_domains = enrichmentRANDOM, 
               domains_known_mapped = domains_known_mapped, type = "count", plot_type = "l")
```

## As we include more proteins, the Fisher test odds ratio decreases (we add more stuff that is not known). Odds ratio measures how much more likely are we to find a domain using our procedure if it’s a known domain as compared to if it’s not a known domain.

```{r fisher_odds_ratio, fig.height = 9, fig.width = 10}
plotEnrichment(enrichment, enrichment_justfreq, enrichment_low_back, enrichment_low_deg, enrichment_low_deg_back,
               enrichment_count, enrichmentRev, enrichmentMix,
               enrichmentFISHERodds, enrichmentFISHER_justodds,
               enrichmentFISHERpval, enrichmentFISHER_justpval, enrichmentFISHERoddsBig,
               random_domains = enrichmentRANDOM, 
               domains_known_mapped = domains_known_mapped, type = "odds_ratio", plot_type = "l")
```

## corresponding P-values from the Fisher test 

```{r fisher_pval, fig.height = 9, fig.width = 10}
plotEnrichment(enrichment, enrichment_justfreq, enrichment_low_back, enrichment_low_deg, enrichment_low_deg_back,
               enrichment_count, enrichmentRev, enrichmentMix,
               enrichmentFISHERodds, enrichmentFISHER_justodds,
               enrichmentFISHERpval, enrichmentFISHER_justpval, enrichmentFISHERoddsBig,
               random_domains = enrichmentRANDOM, 
               domains_known_mapped = domains_known_mapped, type = "pval", plot_type = "l")
```

## How many viral proteins are known per each of the domain instances in top 200 protein-domain pairs?

```{r top200_n_inter}
selectTopHits = function(res, N){
    res$data_pval = unique(res$data_with_pval[,.(IDs_interactor_viral, IDs_domain_human, p.value, domain_type, domain_count, IDs_interactor_viral_degree)])
    pairs200pval = res$data_pval[order(p.value, decreasing = F)[1:N], max(p.value)]
    
    restop100 = res
    restop100$data_with_pval = restop100$data_with_pval[p.value <= pairs200pval, ]
    restop100$data_with_pval[, N_viral_per_human_w_domain := length(unique(IDs_interactor_viral)), by = .(IDs_interactor_human, IDs_domain_human)]
    return(restop100)
}
restop100 = selectTopHits(res, N = 250)
plot(restop100, IDs_interactor_human ~ N_viral_per_human_w_domain)
plot(restop100)
```

`r restop100$data_with_pval[N_viral_per_human_w_domain >= 5, length(unique(IDs_interactor_human))]` human proteins with enriched domains have 5 or more viral interacting partners.  
`r restop100$data_with_pval[N_viral_per_human_w_domain >= 10, length(unique(IDs_interactor_human))]` human proteins with enriched domains have 10 or more viral interacting partners.  

### what are those domains? are they known ELM-interacting domains? which proteins they are in? which viral taxons they interact with?

```{r}
restop100$data_with_pval[N_viral_per_human_w_domain >= 10, unique(IDs_domain_human)]
restop100$data_with_pval[N_viral_per_human_w_domain >= 10, unique(IDs_domain_human)] %in% domains_known_mapped
restop100$data_with_pval[N_viral_per_human_w_domain >= 10 & IDs_domain_human == "IPR000504", unique(IDs_interactor_human)]
restop100$data_with_pval[N_viral_per_human_w_domain >= 10 & IDs_domain_human == "IPR000504", unique(Taxid_interactor_viral)]
DT::datatable(restop100$data_with_pval[N_viral_per_human_w_domain >= 10,])
```

## R session information

```{r}
filename = paste0("./processed_data_files/what_we_find_VS_ELM_clust",gsub("-","",Sys.Date()),".RData")
save(list = ls(), file=filename)
#R.utils::gzip(filename = "./processed_data_files/what_we_find_VS_ELM_clust11092017.RData",
#              destname = "./processed_data_files/what_we_find_VS_ELM_clust11092017.RData.gz",
#              remove = T, overwrite = T)
Sys.Date()
sessionInfo()
```