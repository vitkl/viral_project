---
title: "Identify if the domains we have identified tend to bind linear motifs (the domains we have identified are enriched in domains known to bind linear motifs)"
author: "Vitalii Kleshchevnikov"
date: "17/08/2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

packages = c("MItools", "rtracklayer", "ggplot2", "GGally")
if(mean(packages %in% names(installed.packages()[,"Package"])) != 1){
    packages_to_install = packages[!packages %in% names(installed.packages()[,"Package"])]
    # specifying mirror is necessary for some Linux systems
    install.packages(packages_to_install, dependencies = T, repos = "http://mirrors.ebi.ac.uk/CRAN/")
    packages_to_install = packages[!packages %in% names(installed.packages()[,"Package"])]
    source("https://bioconductor.org/biocLite.R")
    biocLite(packages_to_install)
    devtools::install_github("vitkl/MItools")
}

suppressPackageStartupMessages({
    library(MItools)
    library(rtracklayer)
    library(ggplot2)
    library(GGally)
})
```

## Setting up how many cores to use for analysis and fold-enrichment vs freqency

```{r}
# cores to use for multiprocessing: is the number of cores is small -> we are not on a cluster -> use all; if the number of cores is large -> we are on cluster -> use only 15 or 7 cores
if(detectCores() <= 4) cores_to_use = detectCores() - 1
if(detectCores() > 4) cores_to_use = 15

# Do I remove proteins with missing domains before ... not relevant anymore (however necessary for the code to work as of 17.08): these proteins are accounted for in permutationPval function and the count of human proteins not missing domains per viral protein is reported in not_missing column
include_missing_Z_as_zero = TRUE
# how many permutations?
N_permut = 1000
```

# How many of the domains identified using our approach are in the ELM database (as compared to the population of all domains we tested)?

## Calculate empirical pvalues using either frequency of a domain among interacting partners of viral protein or Fisher test p-value

```{r calculate_pvals}
# frequency
data = fread("./processed_data_files/viral_human_net_w_domains", sep = "\t", stringsAsFactors = F)
time = proc.time()
res = permutationPval(interactions2permute = IDs_interactor_viral ~ IDs_interactor_human, # first set of interacting pairs
                      associations2test = IDs_interactor_viral ~ IDs_domain_human, # second set of interacting pairs
                      node_attr = list(IDs_interactor_viral ~ IDs_interactor_viral_degree,
                                       IDs_domain_human ~ domain_count,
                                       IDs_interactor_viral + IDs_domain_human ~ domain_frequency_per_IDs_interactor_viral),
                      data = data,
                      statistic = IDs_interactor_viral + IDs_domain_human ~ .N / IDs_interactor_viral_degree,
                      select_nodes = IDs_interactor_viral ~ IDs_interactor_viral_degree > 1,
                      N = N_permut,
                      cores = cores_to_use, seed = 2, include_missing_Z_as_zero = include_missing_Z_as_zero)
proc.time() - time
hist(res$data_with_pval[, .(IDs_interactor_viral, IDs_domain_human, p.value)][, p.value], breaks = seq(0,1,0.01))

# Fisher test
# contingency matrix:
matrix(c("unique(domain_count_per_IDs_interactor_viral)", 
         "unique(IDs_interactor_viral_degree) - unique(domain_count_per_IDs_interactor_viral)", 
         "unique(domain_count)", 
         "unique(N_prot_w_interactors) - unique(domain_count)"),2,2)
# test
time = proc.time()
resFISHER = permutationPval(interactions2permute = IDs_interactor_viral ~ IDs_interactor_human, # first set of interacting pairs (XY)
                            associations2test = IDs_interactor_viral ~ IDs_domain_human, # second set of interacting pairs (YZ)
                            node_attr = list(IDs_interactor_viral ~ IDs_interactor_viral_degree, # attribute of X
                                             IDs_domain_human ~ domain_count + N_prot_w_interactors, # attributes of Z
                                             IDs_interactor_viral + IDs_domain_human ~ domain_count_per_IDs_interactor_viral), # attribute of both X and Z
                            data = data, # data.table containing data
                            statistic = IDs_interactor_viral + IDs_domain_human ~ fisher.test(
                                matrix(c(unique(domain_count_per_IDs_interactor_viral), 
                                         unique(IDs_interactor_viral_degree) - unique(domain_count_per_IDs_interactor_viral),
                                         unique(domain_count), 
                                         unique(N_prot_w_interactors) - unique(domain_count)),
                                       2,2), 
                                alternative = "greater", conf.int = F)$p.value, # formula to calculate statisic by evaluating right-hand-side expression for each X and Z pair, right-hand-side expression is what is normally put in j in data.table DT[i, j, by], left-hand-side expression contains column names of X and Z which are used in by in data.table
                            select_nodes = IDs_interactor_viral ~ IDs_interactor_viral_degree > 1, # select a subset of the data, only nodes 
                            N = N_permut, # number of permutations
                            cores = cores_to_use, seed = 1, include_missing_Z_as_zero = include_missing_Z_as_zero)
# permutationPval returns the number of cases when observed statistic is lower than permuted statitic (right tail of the distribution), in this case we are interested in the reverse - the lower tail
resFISHER$data_with_pval[, p.value := 1 - p.value]
proc.time() - time
hist(resFISHER$data_with_pval[, .(IDs_interactor_viral, IDs_domain_human, p.value)][, p.value], breaks = seq(0,1,0.01))
```

## Viral protein degree and the background domain count of top-scoring proteins

```{r plot_DegreeVScount, fig.height = 12, fig.width = 12}
# simplify data for plotting
resFISHER$data_pval_simp = unique(resFISHER$data_with_pval[, .(IDs_interactor_viral, IDs_domain_human, IDs_interactor_viral_degree, domain_count, domain_count_per_IDs_interactor_viral, p.value)])
res$data_pval_simp = unique(res$data_with_pval[, .(IDs_interactor_viral, IDs_domain_human, IDs_interactor_viral_degree, domain_count, domain_count_per_IDs_interactor_viral, p.value)])

# function to accomodate ggplot2::geom_bin2d in GGally::ggpairs, taken from http://ggobi.github.io/ggally/#custom_functions
d2_bin_log10 <- function(data, mapping, ..., low = "#132B43", high = "#56B1F7") {
    ggplot(data = data, mapping = mapping) +
        geom_bin2d(...) +
        scale_fill_gradient(low = low, high = high) +
        scale_y_log10() + scale_x_log10()
}

log10_density = function(data, mapping, ...){
    ggplot(data = data, mapping = mapping) +
        geom_density(...) +
        scale_x_log10()
}

# frequency of a domain
GGally::ggpairs(res$data_pval_simp[order(p.value)[1:250],.(domain_count, 
                                            IDs_interactor_viral_degree, 
                                            domain_count_per_IDs_interactor_viral,
                                            p.value)], 
                lower = list(continuous = d2_bin_log10)#, 
                #diag = list(continuous = geom_density)
                ) +
    theme_light() +
    theme(strip.text.y = element_text(angle = 0, size = 10),
          strip.text.x = element_text(angle = 90, size = 10)) +
    ggtitle("2D-bin plots of 250 top-scoring viral protein - human domain pairs, \n statistic: frequency of a domain among interacting partners of a viral protein")

# Fisher test p-value
GGally::ggpairs(resFISHER$data_pval_simp[order(p.value)[1:250],.(domain_count, 
                                                  IDs_interactor_viral_degree, 
                                                  domain_count_per_IDs_interactor_viral,
                                                  p.value)], 
                lower = list(continuous = d2_bin_log10)#, 
                #diag = list(continuous = geom_density)
                ) +
    theme_light() +
    theme(strip.text.y = element_text(angle = 0, size = 10),
          strip.text.x = element_text(angle = 90, size = 10)) +
    ggtitle("2D-bin plots of 250 top-scoring viral protein - human domain pairs, \n statistic: Fisher test p-value")
```

## Map domains known to interact with linear motifs from ELM to the domains we found

```{r ELMdownload_and_map}
interactiondomains = fread("http://elm.eu.org/interactiondomains.tsv")
interactiondomains[, pfam_id := `Interaction Domain Id`]

domains_known = interactiondomains[, unique(pfam_id)]

"./processed_data_files/InterProScan_domains_nonredundant.gff3"
"./processed_data_files/all_human_viral_protein_domains.gff3.gz"
InterProScan_domains_nonred = import(con = "../viral_project/processed_data_files/InterProScan_domains_nonredundant.gff3", format = "gff3")
domains_mapping = unique(data.table(any_id = as.character(InterProScan_domains_nonred$Name), interpro_id = as.character(InterProScan_domains_nonred$Dbxref)))
domains_known_mapped = unique(domains_mapping[any_id %in% domains_known, interpro_id])
domains_not_mapped = unique(domains_known[!domains_known %in% domains_mapping$any_id])
```

I did Fisher test to evaluate if the domains that we find are enriched in domains known to interact with linear motifs (from ELM). I have picked some number of viral protein - human domain associations from the top (by p-value). Then I counted how many known domains we have found and did Fisher test. I decided to compare two statistic choices (frequency of a domain among interacting partners of a viral protein or Fisher test p-value) on how many of the known domains we tend to find. Finally, I was choosing different cutoffs (different number of top p-value pairs). 

```{r overrepresentation_test}
test_enrichment = function(N, res, domains_known_mapped){
    res$data_pval = unique(res$data_with_pval[,.(IDs_interactor_viral, IDs_domain_human, p.value, domain_type, domain_count, IDs_interactor_viral_degree)])
    res$data_pval[, pval_fdr := p.adjust(p.value, method = "fdr")]
    hist(res$data_pval[, pval_fdr], breaks = seq(0,1,0.01))
    
    domains_found = res$data_pval[order(p.value)[1:N], unique(IDs_domain_human)]
    
    alldomains = res$data_pval[, unique(IDs_domain_human)]
    known = factor(alldomains %in% domains_known_mapped, levels = c("TRUE", "FALSE"))
    found = factor(alldomains %in% domains_found, levels = c("TRUE", "FALSE"))
    table_res = table(known, found)
    
    test = fisher.test(table(known, found), alternative = "greater", conf.int = T)
    
    return(c(test$p.value, test$estimate, table_res["TRUE", "TRUE"]))
}

enrichment = sapply(seq(25, 500, 25), test_enrichment, res, domains_known_mapped)
colnames(enrichment) = seq(25, 500, 25)
enrichmentFISHER = sapply(seq(25, 500, 25), test_enrichment, resFISHER, domains_known_mapped)
colnames(enrichmentFISHER) = seq(25, 500, 25)
```

## As we include more proteins, the number of known domains we find increases and then levels off (probably because some of the known domains do not interact with viral proteins).

```{r domains_found, fig.height = 6, fig.width = 9}
plot(colnames(enrichment), enrichment[3,], ylab = "known domain found", xlab = "top N viral protein - domain pairs selected", col = "red", type = "l", ylim = c(0,length(domains_known_mapped)+1))
lines(x = colnames(enrichment), y = enrichmentFISHER[3,], col = "blue", type = "l")
abline(h = length(domains_known_mapped), col = "green")
legend(x = 80, y = 50, c("statictic used in permutation test:","domain frequency among interactors of a viral protein", "Fisher test pval: domain overrepresentation over the background", "domains known to interact with linear motifs"), col = c("white","red", "blue", "green"), lty = 1 , merge = TRUE)
```

## As we include more proteins, the Fisher test odds ratio decreases (we add more stuff that is not known). Odds ratio measures how much more likely are we to find a domain using our procedure if it’s a known domain as compared to if it’s not a known domain.

```{r fisher_odds_ratio, fig.height = 6, fig.width = 9}
plot(colnames(enrichment), enrichment[2,], ylab = "Fisher test odds ratio", xlab = "top N viral protein - domain pairs selected", col = "red", type = "l", ylim = c(0,max(c(enrichment[2,], enrichmentFISHER[2,]))))
lines(x = colnames(enrichment), y = enrichmentFISHER[2,], col = "blue", type = "l")
legend(x = 80, y = max(enrichment[2,]) - 1, c("statictic used in permutation test:","domain frequency among interactors of a viral protein", "Fisher test pval: domain overrepresentation over the background"), col = c("white","red", "blue"), lty = 1 ,merge = TRUE)
```

## corresponding P-values from the Fisher test 

```{r fisher_pval, fig.height = 6, fig.width = 9}
plot(colnames(enrichment), enrichment[1,], ylab = "Fisher test pvalue", xlab = "top N viral protein - domain pairs selected", col = "red", type = "l", ylim = c(0,max(c(enrichment[1,], enrichmentFISHER[1,]))))
lines(x = colnames(enrichment), y = enrichmentFISHER[1,], col = "blue", type = "l")
legend(x = 80, y = max(c(enrichment[1,], enrichmentFISHER[1,])), c("statictic used in permutation test:","domain frequency among interactors of a viral protein", "Fisher test pval: domain overrepresentation over the background"), col = c("white","red", "blue"), lty = 1 ,merge = TRUE)
```


## R session information

```{r}
rm(list = ls())
gc()
Sys.Date()
sessionInfo()
```