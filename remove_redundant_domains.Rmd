---
title: "remove_redundant_domains"
author: "Vitalii Kleshchevnikov"
date: "3/09/2017"
output: 
  html_document: 
    keep_md: yes
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

packages = c("data.table","downloader","R.utils","UniProt.ws", "PSICQUIC", "ggplot2", "rtracklayer", "Biostrings", "MItools", "GGally")
if(mean(packages %in% names(installed.packages()[,"Package"])) != 1){
    packages_to_install = packages[!packages %in% names(installed.packages()[,"Package"])]
    # specifying mirror is necessary for some Linux systems
    install.packages(packages_to_install, dependencies = T, repos = "http://mirrors.ebi.ac.uk/CRAN/")
    packages_to_install = packages[!packages %in% names(installed.packages()[,"Package"])]
    source("https://bioconductor.org/biocLite.R")
    biocLite(packages_to_install)
    devtools::install_github("vitkl/MItools")
}

suppressPackageStartupMessages({
    library(data.table)
    library(downloader)
    library(R.utils)
    library(UniProt.ws)
    library(PSICQUIC)
    library(ggplot2)
    library(rtracklayer)
    library(Biostrings)
    library(MItools)
    library(GGally)
})
```

Date: `r Sys.time()`

## Read InterProScan result and filter for "Domain", "Active_site", "Binding_site", "Conserved_site", "PTM" signatures

I read InterProScan result and the InterPro_entry_types file. InterProScan output format description: https://github.com/ebi-pf-team/interproscan/wiki/OutputFormats  

```{r InterPro_entry_types}
# read InterProScan result, download and add InterPro Entry Types information, extract from relevant columns and add names metadata and sequence length information
InterProScan_result = readInterProGFF3("./processed_data_files/all_human_viral_protein_domains.gff3.gz", processed = F)
InterProScan_result = addInterProEntryTypes(InterProScan_result, "./data_files/entry.list")
InterProScan_domains = SubsetByInterProEntryType(InterProScan_result, c("Domain", 
    "Active_site", "Binding_site", "Conserved_site", "PTM", "Repeat"))
```

## Remove redundancy in the identified domains (signatures of the same domain from different InterPro member databases + domain families)

In domain families: assign all domains to the top domain.

```{r collapse_by_IPR_ID}
InterProTree = loadInterProTree(filename = "./data_files/interpro_ParentChildTreeFile.txt")
# find all InterProIDs that have children InterProIDs
InterProTree_level1 = getLevelXchildren(tree = InterProTree, level = 1) 
has_children = InterProScan_domains$Dbxref %in% InterProTree_level1$allchildren

# map top InterProIDs in the hierarchy when InterProIDs have have children InterProIDs
InterProScan_domains$topInterProID = InterProScan_domains$Dbxref
InterProScan_domains$topInterProID[has_children] = InterProTree_level1$level1[match(InterProScan_domains$Dbxref, InterProTree_level1$allchildren)][has_children]

# collapse 
InterProScan_domains_nonred = collapseByInterProID(InterProScan_features = InterProScan_domains, id_col = "topInterProID")
```

We used to have `r length(unique(InterProScan_domains$Name))` domains and `r length(unique(paste0(InterProScan_domains$Name,seqnames(InterProScan_domains))))` protein-domain pairs.   
After combining the signatures of the same domain from different InterPro member databases we have `r length(unique(InterProScan_domains$Dbxref))` domains and `r length(unique(paste0(InterProScan_domains$Dbxref,seqnames(InterProScan_domains))))` protein-domain pairs.   
Finally, after considering only one domain per domain family we are left with `r length(unique(InterProScan_domains$topInterProID))` domains and `r length(unique(paste0(InterProScan_domains$topInterProID,seqnames(InterProScan_domains))))` protein-domain pairs.  

```{r}
# save results
export(InterProScan_domains_nonred, con = "./processed_data_files/InterProScan_domains_nonredundant.gff3", format = "gff3")
gzip(filename = "./processed_data_files/InterProScan_domains_nonredundant.gff3", destname = "./processed_data_files/InterProScan_domains_nonredundant.gff3.gz", overwrite = T, remove = T)

InterProScan_domains_nonred2 = readInterProGFF3("./processed_data_files/InterProScan_domains_nonredundant.gff3.gz", processed = T)

# take protein-domain pair discarding range information
protein_domain_pair = unique(data.table(IDs_protein = as.character(seqnames(InterProScan_domains_nonred)),
                                        IDs_domain = as.character(InterProScan_domains_nonred$topInterProID),
                                        all_IDs_domain = as.character(InterProScan_domains_nonred$Dbxref),
                                        domain_type = InterProScan_domains_nonred$ENTRY_TYPE))
# save simplified table
fwrite(protein_domain_pair, file = "./processed_data_files/protein_domain_pair", sep = "\t")
```


```{r remove_redundancy, eval=FALSE}
positionalDistance = function(InterProScan_domains, maxgap = 100){
    # generate Granges which contain feature start
    domain_start = resize(InterProScan_domains, width = 1, fix="start", use.names=TRUE)
    # generate Granges which contain feature end
    domain_end = resize(InterProScan_domains, width = 1, fix="end", use.names=TRUE)
    
    # find features with overlapping start (including feature with itself)
    overlap_start = findOverlaps(query = domain_start, maxgap = maxgap)
    # find features with overlapping end (including feature with itself)
    overlap_end = findOverlaps(query = domain_end, maxgap = maxgap)
    
    # remove overlapping start of feature with itself
    overlap_start = overlap_start[(queryHits(overlap_start) != subjectHits(overlap_start))]
    # remove overlapping end of feature with itself
    overlap_end = overlap_end[(queryHits(overlap_end) != subjectHits(overlap_end))]
    
    # find features in which both the start and the end overlap
    overlap_start_n_end = intersect(overlap_start, overlap_end)
    
    # calculate the distance between positions of overlapping start features
    overlap_both_start_dist = distance(domain_start[queryHits(overlap_start_n_end)], domain_start[subjectHits(overlap_start_n_end)])
    # calculate the distance between positions of overlapping end features
    overlap_both_end_dist = distance(domain_end[queryHits(overlap_start_n_end)], domain_end[subjectHits(overlap_start_n_end)])
    
    # sum these distances
    overlap_total_dist = overlap_both_start_dist + overlap_both_end_dist
    
    # map distances to domains
    
}
# generate Granges which contain feature start
domain_start = resize(InterProScan_domains, width = 1, fix="start", use.names=TRUE)
# generate Granges which contain feature end
domain_end = resize(InterProScan_domains, width = 1, fix="end", use.names=TRUE)

# find features with overlapping start (including feature with itself)
overlap_start = findOverlaps(query = domain_start, maxgap = 100)
# find features with overlapping end (including feature with itself)
overlap_end = findOverlaps(query = domain_end, maxgap = 100)

# remove overlapping start of feature with itself
overlap_start = overlap_start[(queryHits(overlap_start) != subjectHits(overlap_start))]
# remove overlapping end of feature with itself
overlap_end = overlap_end[(queryHits(overlap_end) != subjectHits(overlap_end))]

# find features in which both the start and the end overlap
overlap_start_n_end = intersect(overlap_start, overlap_end)

# calculate the distance between positions of overlapping start features
overlap_both_start_dist = distance(domain_start[queryHits(overlap_start_n_end)], domain_start[subjectHits(overlap_start_n_end)])
hist(overlap_both_start_dist, breaks = seq(0,100,1))
# calculate the distance between positions of overlapping end features
overlap_both_end_dist = distance(domain_end[queryHits(overlap_start_n_end)], domain_end[subjectHits(overlap_start_n_end)])
hist(overlap_both_end_dist, breaks = seq(0,100,1))

# sum these distances
overlap_total_dist = overlap_both_start_dist + overlap_both_end_dist
overlap_total_dist = data.table(overlap_total_dist = overlap_total_dist,
                                queryHits = InterProScan_domains[queryHits(overlap_start_n_end)]$Dbxref,
                                subjectHits = InterProScan_domains[subjectHits(overlap_start_n_end)]$Dbxref)
hist(overlap_total_dist, breaks = seq(0,200,1))
abline(v=10)

# select distance difference cutoff
overlap_start_n_end = overlap_start_n_end[overlap_total_dist < 10]
# generate non-redundant domain annotatations by keeping only the first domain signature among overlapping signatures
overlap_start_n_end_nonred = overlap_start_n_end[queryHits(overlap_start_n_end) < subjectHits(overlap_start_n_end)]
InterProScan_domains_nonred = InterProScan_domains[unique(queryHits(overlap_start_n_end_nonred))]
```

## R session information

```{r}
save(list = ls(), file="./processed_data_files/remove_redundant_domains_clust.RData")
R.utils::gzip(filename = "./processed_data_files/remove_redundant_domains_clust.RData",
              destname = "./processed_data_files/remove_redundant_domains_clust.RData.gz",
              remove = T, overwrite = T)

Sys.Date()
sessionInfo()
```